<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="Expressions">Expressions</h1><p>The Expressions screen provides access to all expressions used by the system. <br/>Expressions can be created and attached to various to objects. From the expressions screen the following activities can be performed</p><ul><li><a href="PLUGINS_ROOT/com.netxforge.netxstudio.help/html/tasks/library/expressions/creating_an_expression.html">Create or Modifying an Expression</a></li></ul><p>The Expressions screen</p><p><img border="0" src="PLUGINS_ROOT/com.netxforge.netxstudio.help/img/tasks/library/expressions/expressions.png"/></p><p><strong>New</strong> =&gt; Click on the upright link to create a new expression<br/><strong>Edit</strong> =&gt; Right-click on an expression in the table and select edit. <br/><strong>Filter</strong> =&gt; Type text to filter expressions containing the text</p><h2 id="Typesofexpressions">Types of expressions</h2><p>Expressions are evaluated by the expression engine depending on the job being performed. </p><ul><li>Service Monitoring</li><li>Resource Monitoring</li></ul><h2 id="ExpressionsinServiceMonitoring">Expressions in Service Monitoring</h2><p>[TBD]</p><h2 id="ExpressionsinResourceMonitoring">Expressions in Resource Monitoring</h2><p>In resource monitoring expressions are applied at various stages. Some expressions are always applied, and some are applied depending on if an object has an expression &#8216;attached&#8217;. Attaching an expression simply means telling an object it has an expression. </p><p>The following expressions exist</p><ul><li>Metric Expressions</li><li>Capacity Expressions</li><li>Utilization Expressions</li><li>Tolerance Expressions</li></ul><h2 id="Applicableobjects">Applicable objects</h2><p>The following objects use expressions in resource monitoring: </p><ul><li>Function/Equipment Resources</li></ul><p>Calculate Function and Equipment resource capacities using an expression</p><ul><li>Metric</li></ul><p>Calculate and derive resource values from raw metrics</p><ul><li>Function/Equipment Thresholds</li></ul><p>Calculate and derive threshold values.</p><h2 id="Theresourcemonitoringjob">The resource monitoring job</h2><p>The resource monitoring job executes the expressions in the following sequence</p><ul><li>Execution of the Capacity Expressions for all Nodes. </li><li>Execution of the Utilization Expressions for all Resources in all Nodes. </li><li>Execution of the Tolerance Expressions for all Nodes. </li></ul><p>Capacity Expressions </p><p>A capacity expression, is an expression which will populate the capacity values of a resource. <br/>It is typically using the specification of the vendor to calculate the value of the capacity of a resource. </p><p>Example: </p><p>this.FUNCTION -&gt; RESOURCE sgsn_attached_users CAP = this.EQUIPMENT BOARD.count * 5; </p><p>In this example for the current node the capacity values of the resource &#8220;sgsn_attached_users&#8221; will be the total of equipments with code &#8220;BOARD&#8221; multiplied by 5. In other words we count the boards of a specific type, <br/>multiply them by 5 and store the result in the capacity. </p><h2 id="ExpressionSyntax">Expression Syntax</h2><p>The expression engine scripting grammar specification has been carefully designed to support the following facilities. </p><ul><li>Type (less) grammar.</li></ul><ul><li>Contextual grammar. (Acts in the context of an object and period). </li><li>Data Model entity access.</li></ul><ul><li>Scoping and nesting of expressions. </li></ul><ul><li>Statements<ul><li>Expression Statements</li><li>Assignment Statements</li><li>Compound Statements</li></ul></li></ul><ul><li>Operators<ul><li>Arithmetic Operations. </li><li>Logical Operations. </li><li>Binary Operations</li></ul></li></ul><ul><li>Functions<ul><li>Native Functions</li></ul></li><li>Defined functions</li></ul><h3 id="FormattingConventions">Formatting Conventions</h3><p>For better readability of the grammar, the following conventions are followed throughout this chapter.  </p><ul><li>Model types are written in capital letters i.e. NODE. </li><li>Variable or function definitions are plain text i.e. erlang() </li><li>Keywords are non-capital letter with bold face. For example if</li></ul><p>References to parts of the grammar, like an Expression Statement is enclosed with chevrons, i.e. &lt; Expression Statement&gt; or …</p><h3 id="Typelessgrammar">Type (less) grammar</h3><p>The grammar is a type less or dynamically typed grammar. This means that, when working with variables or function arguments, specification of the type is not needed. The type however is interpreted based on the value of the variable or argument.</p><p>The following type values are defined: </p><table><tr><th>Type </th><th>Description</th><th>Possible values</th></tr><tr><td>Boolean </td><td>A Boolean value</td><td>true or false</td></tr><tr><td>Numeric </td><td>A numeric value </td><td>-1, 0.3, 5000000</td></tr><tr><td>Range </td><td>A collection of values</td><td>[4,5,6] or [NODE1, NODE2, etc..]</td></tr><tr><td>Object </td><td>An object </td><td>Boolean, Numeric, Binary, Range, Timestamp or any of the Data Model Entities accessible in the grammar</td></tr></table><p>To find out the type of an object, the following syntax is used:<br/>[TODO, Not implemented.]</p><h3 id="Contextualgrammar">Contextual grammar </h3><ul><li>The grammar acts in the context of an object, which has to be set before a script is executed. The context Object is named Syntax: this</li></ul><ul><li>The grammar acts in the context of a period, which has to be set before a script is executed. All values within this period will be within context when executing the script. The context period is not accessible from with the script, but used when needed by the expression interpreter. </li></ul><h3 id="DataModelentityAccess">Data Model entity Access</h3><p>The most common objective is to store/retrieve values from resources. Resources are part of EQUIPMENT and FUNCTION.  Model access, permits the access to entities in the Data Model.</p><p>The entities which are set as context.  </p><ul><li>NODE</li><li>RESOURCE</li></ul><p>The following entities are accessed indirectly (See the examples further on). </p><ul><li>METRIC</li><li>LINK</li><li>EQUIPMENT</li><li>FUNCTION</li></ul><p>PARAMETER</p><p>[TODO, To be further considered]</p><ul><li>SERVICE</li><li>SERVICEPROFILE</li><li>SERVICEDISTRIBUTION</li><li>RFSSERVICE</li></ul><p>Model navigation permits, the access to some of the relevant Data Model entities. The result of model navigation can be used in statements (i.e. Expression, Assignment and Compound), where relevant.  </p><h4 id="Contextaccess">Context access</h4><p><strong>Description:</strong> To access the current context object.<br/><strong>Syntax:</strong> this ...;<br/><strong>Returns:</strong> The current context object. (Either NODE or RESOURCE). </p><h4 id="AccesstoaFunctionorEquipment">Access to a Function or Equipment</h4><p><strong>Description:</strong> To access a function or equipment. <br/><strong>Syntax:</strong> this.FUNCTION <em>functionname</em> / this.EQUIPMENT <em>equipmentcode</em> ;<br/><strong>Returns:</strong> The current context, and from this a function or equipment. </p><h4 id="AccesstoaResource">Access to a Resource</h4><p><strong>Description:</strong> To access a resource. <br/><strong>Syntax:</strong> this.FUNCTION <em>functionname</em> -&gt; RESOURCE <em>expressionname</em>  / this.EQUIPMENT <em>equipmentcode</em> -&gt; RESOURCE <em>expressionname</em>;<br/><strong>Returns:</strong> The current context, and from this a function or equipment. </p><h4 id="AccesstoaResourcevaluerangefromaNODEcontext.">Access to a Resource value range from a NODE context.</h4><p>As described in the <a href="PLUGINS_ROOT/com.netxforge.netxstudio.help/html/getting_started/data_structure.html">Data Structure</a> , a Resource has multiple value ranges. Value ranges<br/>can be directly addressed by the NetXScript grammar.  </p><p><strong>Description:</strong> To access a value range with metric values <br/><strong>Syntax:</strong> this.FUNCTION <em>functionname</em> -&gt; RESOURCE <em>expression_name</em> METRIC [AVG/BH] <em>interval</em><br/><strong>Returns:</strong> The current context, and from this a function or equipment, then a resource and then the metric range. <br/><strong>options:</strong> The type of value range either AVG (Average) or BH (Busy Hour). </p><p><strong>Description:</strong> To access a value range with capacity values<br/><strong>Syntax:</strong> this.FUNCTION <em>functionname</em> -&gt; RESOURCE <em>expression_name</em> CAP <em>interval</em><br/><strong>Returns:</strong> The current context, and from this a function or equipment, then a resource and then the capacity range. </p><p><strong>Description:</strong> To access a value range with utilization values<br/><strong>Syntax:</strong> this.FUNCTION <em>functionname</em> -&gt; RESOURCE <em>expression_name</em> UTILIZATION <em>interval</em> <br/><strong>Returns:</strong> The current context, and from this a function or equipment, then a resource and then the utilization range. </p><h4 id="AccesstoaResourcevaluerangefromaRESOURCEcontext.">Access to a Resource value range from a RESOURCE context.</h4><p>If the context is a RESOURCE, we have direct access to each of the value ranges: </p><p><strong>Description:</strong> To access a value range with metric values <br/><strong>Syntax:</strong> this METRIC [AVG/BH] <em>interval</em><br/><strong>Returns:</strong> The current context (The resource) , then the metric range followed by the interval <br/><strong>options:</strong> The type of value range either AVG (Average) or BH (Busy Hour). </p><h3 id="Scopingandnestingofexpressions">Scoping and nesting of expressions</h3><h4 id="Scoping">Scoping </h4><p>A scope, is a partition in the grammar, which is self-contained, in practice defined variables can overlap variables in the outer scope.  <br/><strong>Description:</strong> Scoping is achieved by putting expressions and assignments in brackets {} variables defined with this scope, are only visible within that scope. <br/><strong>Syntax:</strong> {...}</p><h4 id="Nesting">Nesting</h4><p><strong>Description:</strong> Nested scopes are achieved by nesting the curly brackets. <br/>Syntax: {…{…}}</p><h3 id="Statements">Statements</h3><p>Statements can be:</p><p>Expression statements<br/>Assignment statements<br/>Compound statements</p><h4 id="ExpressionStatement">Expression Statement</h4><p><strong>Description:</strong> Expression results are Numeric, Boolean, Range or Object. The types of operations and operands used in an expression, will determine if the expression return type.</p><h4 id="AssignmentStatement">Assignment Statement</h4><p><strong>Description:</strong> Assignment statements assign a value to a variable or entity attribute or reference. Type conformance is implied. <br/><strong>Syntax:</strong> =   +=   [NOT implemented -=   *=   /=   %=] </p><h4 id="CompoundStatements">Compound Statements</h4><p><strong>Description:</strong> the if … else…. Compound statement <br/>Syntax: </p><p>if( &lt;Boolean expression&gt; ){<br/>…<br/>} else {<br/>…<br/>}</p><p>Description of the while Compound statement<br/>Syntax:</p><p>while( &lt;Boolean expression&gt; ) {<br/>…<br/>}</p></body></html>