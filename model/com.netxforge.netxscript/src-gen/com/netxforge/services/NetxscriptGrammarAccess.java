/*
* generated by Xtext
*/

package com.netxforge.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class NetxscriptGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Mod");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Keyword cModKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cNameAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0_1_0 = (RuleCall)cNameAssignment_0_1.eContents().get(0);
		private final Assignment cImportsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportsImportParserRuleCall_1_0 = (RuleCall)cImportsAssignment_1.eContents().get(0);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cFunctionsAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cFunctionsFunctionParserRuleCall_2_0_0 = (RuleCall)cFunctionsAssignment_2_0.eContents().get(0);
		private final Assignment cStatementsAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_2_1_0 = (RuleCall)cStatementsAssignment_2_1.eContents().get(0);
		
		//Mod:
		//	("mod" name=ID)? imports+=Import* (functions+=Function+ | statements+=Statement+);
		public ParserRule getRule() { return rule; }

		//("mod" name=ID)? imports+=Import* (functions+=Function+ | statements+=Statement+)
		public Group getGroup() { return cGroup; }

		//("mod" name=ID)?
		public Group getGroup_0() { return cGroup_0; }

		//"mod"
		public Keyword getModKeyword_0_0() { return cModKeyword_0_0; }

		//name=ID
		public Assignment getNameAssignment_0_1() { return cNameAssignment_0_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0_1_0() { return cNameIDTerminalRuleCall_0_1_0; }

		//imports+=Import*
		public Assignment getImportsAssignment_1() { return cImportsAssignment_1; }

		//Import
		public RuleCall getImportsImportParserRuleCall_1_0() { return cImportsImportParserRuleCall_1_0; }

		//functions+=Function+ | statements+=Statement+
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//functions+=Function+
		public Assignment getFunctionsAssignment_2_0() { return cFunctionsAssignment_2_0; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_2_0_0() { return cFunctionsFunctionParserRuleCall_2_0_0; }

		//statements+=Statement+
		public Assignment getStatementsAssignment_2_1() { return cStatementsAssignment_2_1; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_1_0() { return cStatementsStatementParserRuleCall_2_1_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportURIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_0 = (RuleCall)cImportURIAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importURI=STRING;
		public ParserRule getRule() { return rule; }

		//"import" importURI=STRING
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importURI=STRING
		public Assignment getImportURIAssignment_1() { return cImportURIAssignment_1; }

		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_0() { return cImportURISTRINGTerminalRuleCall_1_0; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cArgsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cArgsArgumentParserRuleCall_3_0_0 = (RuleCall)cArgsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cArgsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cArgsArgumentParserRuleCall_3_1_1_0 = (RuleCall)cArgsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBlockBlockParserRuleCall_5_0 = (RuleCall)cBlockAssignment_5.eContents().get(0);
		
		//Function:
		//	"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block;
		public ParserRule getRule() { return rule; }

		//"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block
		public Group getGroup() { return cGroup; }

		//"def"
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(args+=Argument ("," args+=Argument)*)?
		public Group getGroup_3() { return cGroup_3; }

		//args+=Argument
		public Assignment getArgsAssignment_3_0() { return cArgsAssignment_3_0; }

		//Argument
		public RuleCall getArgsArgumentParserRuleCall_3_0_0() { return cArgsArgumentParserRuleCall_3_0_0; }

		//("," args+=Argument)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//args+=Argument
		public Assignment getArgsAssignment_3_1_1() { return cArgsAssignment_3_1_1; }

		//Argument
		public RuleCall getArgsArgumentParserRuleCall_3_1_1_0() { return cArgsArgumentParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//block=Block
		public Assignment getBlockAssignment_5() { return cBlockAssignment_5; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_5_0() { return cBlockBlockParserRuleCall_5_0; }
	}

	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argument");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Argument:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class AbstractVarOrArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractVarOrArgument");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArgumentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractVarOrArgument:
		//	VariableStatement | Argument;
		public ParserRule getRule() { return rule; }

		//VariableStatement | Argument
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableStatement
		public RuleCall getVariableStatementParserRuleCall_0() { return cVariableStatementParserRuleCall_0; }

		//Argument
		public RuleCall getArgumentParserRuleCall_1() { return cArgumentParserRuleCall_1; }
	}

	public class AbstractFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractFunction");
		private final RuleCall cFunctionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//AbstractFunction:
		//	Function;
		public ParserRule getRule() { return rule; }

		//Function
		public RuleCall getFunctionParserRuleCall() { return cFunctionParserRuleCall; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block:
		//	{Block} "{" statements+=Statement* "}";
		public ParserRule getRule() { return rule; }

		//{Block} "{" statements+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final RuleCall cVariableStatementParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0);
		private final RuleCall cAssignmentStatementParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cPlusAssignmentStatementParserRuleCall_0_0_2 = (RuleCall)cAlternatives_0_0.eContents().get(2);
		private final RuleCall cReferenceAssignmentStatementParserRuleCall_0_0_3 = (RuleCall)cAlternatives_0_0.eContents().get(3);
		private final RuleCall cReturnStatementParserRuleCall_0_0_4 = (RuleCall)cAlternatives_0_0.eContents().get(4);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cIfStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cWhileStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBlockParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Statement:
		//	(VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | ReturnStatement)
		//	";" | IfStatement | WhileStatement | Block;
		public ParserRule getRule() { return rule; }

		//(VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | ReturnStatement) ";"
		//| IfStatement | WhileStatement | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//(VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | ReturnStatement) ";"
		public Group getGroup_0() { return cGroup_0; }

		//VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | ReturnStatement
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }

		//VariableStatement
		public RuleCall getVariableStatementParserRuleCall_0_0_0() { return cVariableStatementParserRuleCall_0_0_0; }

		//AssignmentStatement
		public RuleCall getAssignmentStatementParserRuleCall_0_0_1() { return cAssignmentStatementParserRuleCall_0_0_1; }

		//PlusAssignmentStatement
		public RuleCall getPlusAssignmentStatementParserRuleCall_0_0_2() { return cPlusAssignmentStatementParserRuleCall_0_0_2; }

		//ReferenceAssignmentStatement
		public RuleCall getReferenceAssignmentStatementParserRuleCall_0_0_3() { return cReferenceAssignmentStatementParserRuleCall_0_0_3; }

		//ReturnStatement
		public RuleCall getReturnStatementParserRuleCall_0_0_4() { return cReturnStatementParserRuleCall_0_0_4; }

		//";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//IfStatement
		public RuleCall getIfStatementParserRuleCall_1() { return cIfStatementParserRuleCall_1; }

		//WhileStatement
		public RuleCall getWhileStatementParserRuleCall_2() { return cWhileStatementParserRuleCall_2; }

		//Block
		public RuleCall getBlockParserRuleCall_3() { return cBlockParserRuleCall_3; }
	}

	public class ReturnStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReturnStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cReturnAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cReturnKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//ReturnStatement returns Statement:
		//	{Return} "return" expression=Expression?;
		public ParserRule getRule() { return rule; }

		//{Return} "return" expression=Expression?
		public Group getGroup() { return cGroup; }

		//{Return}
		public Action getReturnAction_0() { return cReturnAction_0; }

		//"return"
		public Keyword getReturnKeyword_1() { return cReturnKeyword_1; }

		//expression=Expression?
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}

	public class IfStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IfStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIfAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIfLogicalParserRuleCall_3_0 = (RuleCall)cIfAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cThenAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cThenBlockParserRuleCall_5_0 = (RuleCall)cThenAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cElseKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cElseAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cElseBlockParserRuleCall_6_1_0 = (RuleCall)cElseAssignment_6_1.eContents().get(0);
		
		//IfStatement returns Statement:
		//	{If} "if" "(" if=Logical ")" then=Block ("else" else=Block)?;
		public ParserRule getRule() { return rule; }

		//{If} "if" "(" if=Logical ")" then=Block ("else" else=Block)?
		public Group getGroup() { return cGroup; }

		//{If}
		public Action getIfAction_0() { return cIfAction_0; }

		//"if"
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//if=Logical
		public Assignment getIfAssignment_3() { return cIfAssignment_3; }

		//Logical
		public RuleCall getIfLogicalParserRuleCall_3_0() { return cIfLogicalParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//then=Block
		public Assignment getThenAssignment_5() { return cThenAssignment_5; }

		//Block
		public RuleCall getThenBlockParserRuleCall_5_0() { return cThenBlockParserRuleCall_5_0; }

		//("else" else=Block)?
		public Group getGroup_6() { return cGroup_6; }

		//"else"
		public Keyword getElseKeyword_6_0() { return cElseKeyword_6_0; }

		//else=Block
		public Assignment getElseAssignment_6_1() { return cElseAssignment_6_1; }

		//Block
		public RuleCall getElseBlockParserRuleCall_6_1_0() { return cElseBlockParserRuleCall_6_1_0; }
	}

	public class WhileStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "WhileStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cPredicateAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPredicateLogicalParserRuleCall_3_0 = (RuleCall)cPredicateAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyBlockParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		
		//WhileStatement returns Statement:
		//	{While} "while" "(" predicate=Logical ")" body=Block;
		public ParserRule getRule() { return rule; }

		//{While} "while" "(" predicate=Logical ")" body=Block
		public Group getGroup() { return cGroup; }

		//{While}
		public Action getWhileAction_0() { return cWhileAction_0; }

		//"while"
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//predicate=Logical
		public Assignment getPredicateAssignment_3() { return cPredicateAssignment_3; }

		//Logical
		public RuleCall getPredicateLogicalParserRuleCall_3_0() { return cPredicateLogicalParserRuleCall_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//body=Block
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_5_0() { return cBodyBlockParserRuleCall_5_0; }
	}

	public class VariableStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVariableAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cVarKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cExpressionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_3_1_0 = (RuleCall)cExpressionAssignment_3_1.eContents().get(0);
		
		//VariableStatement returns Statement:
		//	{Variable} "var" name=ID ("=" expression=Expression)?;
		public ParserRule getRule() { return rule; }

		//{Variable} "var" name=ID ("=" expression=Expression)?
		public Group getGroup() { return cGroup; }

		//{Variable}
		public Action getVariableAction_0() { return cVariableAction_0; }

		//"var"
		public Keyword getVarKeyword_1() { return cVarKeyword_1; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//("=" expression=Expression)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_3_1() { return cExpressionAssignment_3_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_1_0() { return cExpressionExpressionParserRuleCall_3_1_0; }
	}

	public class AssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cAssignmentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVarAbstractVarOrArgumentCrossReference_1_0 = (CrossReference)cVarAssignment_1.eContents().get(0);
		private final RuleCall cVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1 = (RuleCall)cVarAbstractVarOrArgumentCrossReference_1_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//AssignmentStatement returns Statement:
		//	{Assignment} var=[AbstractVarOrArgument] "=" expression=Expression;
		public ParserRule getRule() { return rule; }

		//{Assignment} var=[AbstractVarOrArgument] "=" expression=Expression
		public Group getGroup() { return cGroup; }

		//{Assignment}
		public Action getAssignmentAction_0() { return cAssignmentAction_0; }

		//var=[AbstractVarOrArgument]
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//[AbstractVarOrArgument]
		public CrossReference getVarAbstractVarOrArgumentCrossReference_1_0() { return cVarAbstractVarOrArgumentCrossReference_1_0; }

		//ID
		public RuleCall getVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1() { return cVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}

	public class PlusAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PlusAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPlusAssignmentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cVarAbstractVarOrArgumentCrossReference_1_0 = (CrossReference)cVarAssignment_1.eContents().get(0);
		private final RuleCall cVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1 = (RuleCall)cVarAbstractVarOrArgumentCrossReference_1_0.eContents().get(1);
		private final Keyword cPlusSignEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//PlusAssignmentStatement returns Statement:
		//	{PlusAssignment} var=[AbstractVarOrArgument] "+=" expression=Expression;
		public ParserRule getRule() { return rule; }

		//{PlusAssignment} var=[AbstractVarOrArgument] "+=" expression=Expression
		public Group getGroup() { return cGroup; }

		//{PlusAssignment}
		public Action getPlusAssignmentAction_0() { return cPlusAssignmentAction_0; }

		//var=[AbstractVarOrArgument]
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//[AbstractVarOrArgument]
		public CrossReference getVarAbstractVarOrArgumentCrossReference_1_0() { return cVarAbstractVarOrArgumentCrossReference_1_0; }

		//ID
		public RuleCall getVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1() { return cVarAbstractVarOrArgumentIDTerminalRuleCall_1_0_1; }

		//"+="
		public Keyword getPlusSignEqualsSignKeyword_2() { return cPlusSignEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}

	public class ReferenceAssignmentStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ReferenceAssignmentStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRefAssignmentAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cAssignmentRefAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cAssignmentRefAlternatives_1_0 = (Alternatives)cAssignmentRefAssignment_1.eContents().get(0);
		private final RuleCall cAssignmentRefContextRefParserRuleCall_1_0_0 = (RuleCall)cAssignmentRefAlternatives_1_0.eContents().get(0);
		private final RuleCall cAssignmentRefNodeTypeRefParserRuleCall_1_0_1 = (RuleCall)cAssignmentRefAlternatives_1_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//ReferenceAssignmentStatement returns Statement:
		//	{RefAssignment} assignmentRef=(ContextRef | NodeTypeRef) "=" expression=Expression;
		public ParserRule getRule() { return rule; }

		//{RefAssignment} assignmentRef=(ContextRef | NodeTypeRef) "=" expression=Expression
		public Group getGroup() { return cGroup; }

		//{RefAssignment}
		public Action getRefAssignmentAction_0() { return cRefAssignmentAction_0; }

		//assignmentRef=(ContextRef | NodeTypeRef)
		public Assignment getAssignmentRefAssignment_1() { return cAssignmentRefAssignment_1; }

		//ContextRef | NodeTypeRef
		public Alternatives getAssignmentRefAlternatives_1_0() { return cAssignmentRefAlternatives_1_0; }

		//ContextRef
		public RuleCall getAssignmentRefContextRefParserRuleCall_1_0_0() { return cAssignmentRefContextRefParserRuleCall_1_0_0; }

		//NodeTypeRef
		public RuleCall getAssignmentRefNodeTypeRefParserRuleCall_1_0_1() { return cAssignmentRefNodeTypeRefParserRuleCall_1_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Expression, all operators extend this class. 
		//Expression:
		//	Logical;
		public ParserRule getRule() { return rule; }

		//Logical
		public RuleCall getLogicalParserRuleCall() { return cLogicalParserRuleCall; }
	}

	public class LogicalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Logical");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cAndLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cOrLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEqualityParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Logical	
		//Logical returns Expression:
		//	Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*;
		public ParserRule getRule() { return rule; }

		//Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*
		public Group getGroup() { return cGroup; }

		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }

		//(({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current} "&&" | {Or.left=current} "||"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{And.left=current} "&&"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{And.left=current}
		public Action getAndLeftAction_1_0_0_0() { return cAndLeftAction_1_0_0_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_0_0_1() { return cAmpersandAmpersandKeyword_1_0_0_1; }

		//{Or.left=current} "||"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0_1_0() { return cOrLeftAction_1_0_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_0_1_1() { return cVerticalLineVerticalLineKeyword_1_0_1_1; }

		//right=Equality
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Equality
		public RuleCall getRightEqualityParserRuleCall_1_1_0() { return cRightEqualityParserRuleCall_1_1_0; }
	}

	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cEqualLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cUnequalLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Equal, Non-Equal 
		//Equality returns Expression:
		//	Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*;
		public ParserRule getRule() { return rule; }

		//Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*
		public Group getGroup() { return cGroup; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }

		//(({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }

		//{Equal.left=current} "==" | {Unequal.left=current} "!="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Equal.left=current} "=="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_0_0() { return cEqualLeftAction_1_0_0_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1_0_0_1() { return cEqualsSignEqualsSignKeyword_1_0_0_1; }

		//{Unequal.left=current} "!="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Unequal.left=current}
		public Action getUnequalLeftAction_1_0_1_0() { return cUnequalLeftAction_1_0_1_0; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_1_1() { return cExclamationMarkEqualsSignKeyword_1_0_1_1; }

		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cLesserLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cLesserEqualLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cGreaterLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Group cGroup_1_0_3 = (Group)cAlternatives_1_0.eContents().get(3);
		private final Action cGreaterEqualLeftAction_1_0_3_0 = (Action)cGroup_1_0_3.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_3_1 = (Keyword)cGroup_1_0_3.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAdditionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Lesser, Greater. 
		//Comparison returns Expression:
		//	Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
		//	{GreaterEqual.left=current} ">=") right=Addition)*;
		public ParserRule getRule() { return rule; }

		//Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
		//{GreaterEqual.left=current} ">=") right=Addition)*
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//(({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" | {GreaterEqual.left=current}
		//">=") right=Addition)*
		public Group getGroup_1() { return cGroup_1; }

		//{Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" | {GreaterEqual.left=current}
		//">="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Lesser.left=current} "<"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Lesser.left=current}
		public Action getLesserLeftAction_1_0_0_0() { return cLesserLeftAction_1_0_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_0_1() { return cLessThanSignKeyword_1_0_0_1; }

		//{LesserEqual.left=current} "<="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{LesserEqual.left=current}
		public Action getLesserEqualLeftAction_1_0_1_0() { return cLesserEqualLeftAction_1_0_1_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1_1() { return cLessThanSignEqualsSignKeyword_1_0_1_1; }

		//{Greater.left=current} ">"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_0_2_0() { return cGreaterLeftAction_1_0_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_2_1() { return cGreaterThanSignKeyword_1_0_2_1; }

		//{GreaterEqual.left=current} ">="
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }

		//{GreaterEqual.left=current}
		public Action getGreaterEqualLeftAction_1_0_3_0() { return cGreaterEqualLeftAction_1_0_3_0; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_3_1() { return cGreaterThanSignEqualsSignKeyword_1_0_3_1; }

		//right=Addition
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_1_0() { return cRightAdditionParserRuleCall_1_1_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Addition returns Expression:
		//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//(({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Plus.left=current} "+" | {Minus.left=current} "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Plus.left=current} "+"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Minus.left=current} "-"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_1_0() { return cRightMultiplicationParserRuleCall_1_1_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModuloLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Multiplication returns Expression:
		//	Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*;
		public ParserRule getRule() { return rule; }

		//Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*
		public Group getGroup() { return cGroup; }

		//Unary
		public RuleCall getUnaryParserRuleCall_0() { return cUnaryParserRuleCall_0; }

		//(({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Multi.left=current} "*"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0_0_0() { return cMultiLeftAction_1_0_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }

		//{Div.left=current} "/"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }

		//{Modulo.left=current} "%"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Modulo.left=current}
		public Action getModuloLeftAction_1_0_2_0() { return cModuloLeftAction_1_0_2_0; }

		//"%"
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=Unary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Unary
		public RuleCall getRightUnaryParserRuleCall_1_1_0() { return cRightUnaryParserRuleCall_1_1_0; }
	}

	public class UnaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNativeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cNegationAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cOpExclamationMarkKeyword_1_0_0_1_0 = (Keyword)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cUnaryPlusMinusAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cOpUnaryOperatorParserRuleCall_1_0_1_1_0 = (RuleCall)cOpAssignment_1_0_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Unaries are return type specific. The type on the right should be checked.  
		//Unary returns Expression:
		//	NativeExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary;
		public ParserRule getRule() { return rule; }

		//NativeExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary
		public Alternatives getAlternatives() { return cAlternatives; }

		//NativeExpression
		public RuleCall getNativeExpressionParserRuleCall_0() { return cNativeExpressionParserRuleCall_0; }

		//({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary
		public Group getGroup_1() { return cGroup_1; }

		//{Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Negation} op="!"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Negation}
		public Action getNegationAction_1_0_0_0() { return cNegationAction_1_0_0_0; }

		//op="!"
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }

		//"!"
		public Keyword getOpExclamationMarkKeyword_1_0_0_1_0() { return cOpExclamationMarkKeyword_1_0_0_1_0; }

		//{UnaryPlusMinus} op=UnaryOperator
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{UnaryPlusMinus}
		public Action getUnaryPlusMinusAction_1_0_1_0() { return cUnaryPlusMinusAction_1_0_1_0; }

		//op=UnaryOperator
		public Assignment getOpAssignment_1_0_1_1() { return cOpAssignment_1_0_1_1; }

		//UnaryOperator
		public RuleCall getOpUnaryOperatorParserRuleCall_1_0_1_1_0() { return cOpUnaryOperatorParserRuleCall_1_0_1_1_0; }

		//right=Unary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Unary
		public RuleCall getRightUnaryParserRuleCall_1_1_0() { return cRightUnaryParserRuleCall_1_1_0; }
	}

	public class UnaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPlusSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//UnaryOperator:
		//	"-" | "+";
		public ParserRule getRule() { return rule; }

		//"-" | "+"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//"+"
		public Keyword getPlusSignKeyword_1() { return cPlusSignKeyword_1; }
	}

	public class NativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cNativeExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cNativeFunctionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cNativeFunctionNativeFunctionEnumRuleCall_1_2_0 = (RuleCall)cNativeFunctionAssignment_1_2.eContents().get(0);
		
		/// *
		// *  Nested native functions. 
		// * / NativeExpression returns Expression:
		//	PrimaryExpression ({NativeExpression.left=current} "." nativeFunction=NativeFunction)*;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression ({NativeExpression.left=current} "." nativeFunction=NativeFunction)*
		public Group getGroup() { return cGroup; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({NativeExpression.left=current} "." nativeFunction=NativeFunction)*
		public Group getGroup_1() { return cGroup_1; }

		//{NativeExpression.left=current}
		public Action getNativeExpressionLeftAction_1_0() { return cNativeExpressionLeftAction_1_0; }

		//"."
		public Keyword getFullStopKeyword_1_1() { return cFullStopKeyword_1_1; }

		//nativeFunction=NativeFunction
		public Assignment getNativeFunctionAssignment_1_2() { return cNativeFunctionAssignment_1_2; }

		//NativeFunction
		public RuleCall getNativeFunctionNativeFunctionEnumRuleCall_1_2_0() { return cNativeFunctionNativeFunctionEnumRuleCall_1_2_0; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRangeLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cReferenceParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cFunctionCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIndexedCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cParenthesizedExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
		//PrimaryExpression returns Expression:
		//	Literal | RangeLiteral | Reference | FunctionCall | IndexedCall | ParenthesizedExpression;
		public ParserRule getRule() { return rule; }

		//Literal | RangeLiteral | Reference | FunctionCall | IndexedCall | ParenthesizedExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//Literal
		public RuleCall getLiteralParserRuleCall_0() { return cLiteralParserRuleCall_0; }

		//RangeLiteral
		public RuleCall getRangeLiteralParserRuleCall_1() { return cRangeLiteralParserRuleCall_1; }

		//Reference
		public RuleCall getReferenceParserRuleCall_2() { return cReferenceParserRuleCall_2; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_3() { return cFunctionCallParserRuleCall_3; }

		//IndexedCall
		public RuleCall getIndexedCallParserRuleCall_4() { return cIndexedCallParserRuleCall_4; }

		//ParenthesizedExpression
		public RuleCall getParenthesizedExpressionParserRuleCall_5() { return cParenthesizedExpressionParserRuleCall_5; }
	}

	public class LiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Literal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNumberLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cBooleanLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Assignment cConditionAssignment_1_1_0 = (Assignment)cAlternatives_1_1.eContents().get(0);
		private final Keyword cConditionTrueKeyword_1_1_0_0 = (Keyword)cConditionAssignment_1_1_0.eContents().get(0);
		private final Keyword cFalseKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		
		//Literal returns Expression:
		//	NumberLiteral | {BooleanLiteral} (condition?="true" | "false");
		public ParserRule getRule() { return rule; }

		//NumberLiteral | {BooleanLiteral} (condition?="true" | "false")
		public Alternatives getAlternatives() { return cAlternatives; }

		//NumberLiteral
		public RuleCall getNumberLiteralParserRuleCall_0() { return cNumberLiteralParserRuleCall_0; }

		//{BooleanLiteral} (condition?="true" | "false")
		public Group getGroup_1() { return cGroup_1; }

		//{BooleanLiteral}
		public Action getBooleanLiteralAction_1_0() { return cBooleanLiteralAction_1_0; }

		//condition?="true" | "false"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//condition?="true"
		public Assignment getConditionAssignment_1_1_0() { return cConditionAssignment_1_1_0; }

		//"true"
		public Keyword getConditionTrueKeyword_1_1_0_0() { return cConditionTrueKeyword_1_1_0_0; }

		//"false"
		public Keyword getFalseKeyword_1_1_1() { return cFalseKeyword_1_1_1; }
	}

	public class NumberLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumberLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNumberLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueNUMBERTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//NumberLiteral:
		//	{NumberLiteral} value=NUMBER;
		public ParserRule getRule() { return rule; }

		//{NumberLiteral} value=NUMBER
		public Group getGroup() { return cGroup; }

		//{NumberLiteral}
		public Action getNumberLiteralAction_0() { return cNumberLiteralAction_0; }

		//value=NUMBER
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//NUMBER
		public RuleCall getValueNUMBERTerminalRuleCall_1_0() { return cValueNUMBERTerminalRuleCall_1_0; }
	}

	public class RangeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRangeLiteralAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cValuesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cValuesNUMBERTerminalRuleCall_2_0_0 = (RuleCall)cValuesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cValuesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValuesNUMBERTerminalRuleCall_2_1_1_0 = (RuleCall)cValuesAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////RangeExpression returns Expression:
		////	'['  Expression ']';
		//RangeLiteral:
		//	{RangeLiteral} "[" (values+=NUMBER ("," values+=NUMBER)*)? "]";
		public ParserRule getRule() { return rule; }

		//{RangeLiteral} "[" (values+=NUMBER ("," values+=NUMBER)*)? "]"
		public Group getGroup() { return cGroup; }

		//{RangeLiteral}
		public Action getRangeLiteralAction_0() { return cRangeLiteralAction_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }

		//(values+=NUMBER ("," values+=NUMBER)*)?
		public Group getGroup_2() { return cGroup_2; }

		//values+=NUMBER
		public Assignment getValuesAssignment_2_0() { return cValuesAssignment_2_0; }

		//NUMBER
		public RuleCall getValuesNUMBERTerminalRuleCall_2_0_0() { return cValuesNUMBERTerminalRuleCall_2_0_0; }

		//("," values+=NUMBER)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//values+=NUMBER
		public Assignment getValuesAssignment_2_1_1() { return cValuesAssignment_2_1_1; }

		//NUMBER
		public RuleCall getValuesNUMBERTerminalRuleCall_2_1_1_0() { return cValuesNUMBERTerminalRuleCall_2_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFuncAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFuncAbstractFunctionCrossReference_1_0 = (CrossReference)cFuncAssignment_1.eContents().get(0);
		private final RuleCall cFuncAbstractFunctionIDTerminalRuleCall_1_0_1 = (RuleCall)cFuncAbstractFunctionCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cArgsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cArgsExpressionParserRuleCall_3_0_0 = (RuleCall)cArgsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cArgsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_3_1_1_0 = (RuleCall)cArgsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionCall returns Expression:
		//	{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{FunctionCall}
		public Action getFunctionCallAction_0() { return cFunctionCallAction_0; }

		//func=[AbstractFunction]
		public Assignment getFuncAssignment_1() { return cFuncAssignment_1; }

		//[AbstractFunction]
		public CrossReference getFuncAbstractFunctionCrossReference_1_0() { return cFuncAbstractFunctionCrossReference_1_0; }

		//ID
		public RuleCall getFuncAbstractFunctionIDTerminalRuleCall_1_0_1() { return cFuncAbstractFunctionIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(args+=Expression ("," args+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }

		//args+=Expression
		public Assignment getArgsAssignment_3_0() { return cArgsAssignment_3_0; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_0_0() { return cArgsExpressionParserRuleCall_3_0_0; }

		//("," args+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//args+=Expression
		public Assignment getArgsAssignment_3_1_1() { return cArgsAssignment_3_1_1; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_1_1_0() { return cArgsExpressionParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class IndexedCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IndexedCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVarOrArgumentCallParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cIndexAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cIndexExpressionParserRuleCall_1_1_0 = (RuleCall)cIndexAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//IndexedCall returns Expression:
		//	VarOrArgumentCall ("[" index=Expression "]")?;
		public ParserRule getRule() { return rule; }

		//VarOrArgumentCall ("[" index=Expression "]")?
		public Group getGroup() { return cGroup; }

		//VarOrArgumentCall
		public RuleCall getVarOrArgumentCallParserRuleCall_0() { return cVarOrArgumentCallParserRuleCall_0; }

		//("[" index=Expression "]")?
		public Group getGroup_1() { return cGroup_1; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }

		//index=Expression
		public Assignment getIndexAssignment_1_1() { return cIndexAssignment_1_1; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_1_0() { return cIndexExpressionParserRuleCall_1_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}

	public class VarOrArgumentCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarOrArgumentCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarOrArgumentCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCallAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cCallAbstractVarOrArgumentCrossReference_1_0 = (CrossReference)cCallAssignment_1.eContents().get(0);
		private final RuleCall cCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1 = (RuleCall)cCallAbstractVarOrArgumentCrossReference_1_0.eContents().get(1);
		
		//VarOrArgumentCall returns Expression:
		//	{VarOrArgumentCall} call=[AbstractVarOrArgument];
		public ParserRule getRule() { return rule; }

		//{VarOrArgumentCall} call=[AbstractVarOrArgument]
		public Group getGroup() { return cGroup; }

		//{VarOrArgumentCall}
		public Action getVarOrArgumentCallAction_0() { return cVarOrArgumentCallAction_0; }

		//call=[AbstractVarOrArgument]
		public Assignment getCallAssignment_1() { return cCallAssignment_1; }

		//[AbstractVarOrArgument]
		public CrossReference getCallAbstractVarOrArgumentCrossReference_1_0() { return cCallAbstractVarOrArgumentCrossReference_1_0; }

		//ID
		public RuleCall getCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1() { return cCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1; }
	}

	public class ParenthesizedExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParenthesizedExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ParenthesizedExpression returns Expression:
		//	"(" Expression ")";
		public ParserRule getRule() { return rule; }

		//"(" Expression ")"
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1() { return cExpressionParserRuleCall_1; }

		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}

	public class ReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Reference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cContextRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNodeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cNodeRefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cParamRefParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		/// *
		// * References return values by references to our external model. 
		// * This can be single or ranges of values. The types returned will be limited
		// * to single numerical or ranges of Value types. A Reference extends an Expression
		// * so can participate in statements having expressions. 
		// * / Reference returns Expression:
		//	ContextRef | NodeTypeRef | NodeRef | ParamRef;
		public ParserRule getRule() { return rule; }

		//ContextRef | NodeTypeRef | NodeRef | ParamRef
		public Alternatives getAlternatives() { return cAlternatives; }

		//ContextRef
		public RuleCall getContextRefParserRuleCall_0() { return cContextRefParserRuleCall_0; }

		//NodeTypeRef
		public RuleCall getNodeTypeRefParserRuleCall_1() { return cNodeTypeRefParserRuleCall_1; }

		//NodeRef
		public RuleCall getNodeRefParserRuleCall_2() { return cNodeRefParserRuleCall_2; }

		//ParamRef
		public RuleCall getParamRefParserRuleCall_3() { return cParamRefParserRuleCall_3; }
	}

	public class ParamRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ParamRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParamRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPARAMKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cParamAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cParamParameterCrossReference_2_0 = (CrossReference)cParamAssignment_2.eContents().get(0);
		private final RuleCall cParamParameterFQNParserRuleCall_2_0_1 = (RuleCall)cParamParameterCrossReference_2_0.eContents().get(1);
		
		/// **
		// * Single numerical value reference. 
		// * / ParamRef returns Reference:
		//	{ParamRef} "PARAM" param=[library::Parameter|FQN];
		public ParserRule getRule() { return rule; }

		//{ParamRef} "PARAM" param=[library::Parameter|FQN]
		public Group getGroup() { return cGroup; }

		//{ParamRef}
		public Action getParamRefAction_0() { return cParamRefAction_0; }

		//"PARAM"
		public Keyword getPARAMKeyword_1() { return cPARAMKeyword_1; }

		//param=[library::Parameter|FQN]
		public Assignment getParamAssignment_2() { return cParamAssignment_2; }

		//[library::Parameter|FQN]
		public CrossReference getParamParameterCrossReference_2_0() { return cParamParameterCrossReference_2_0; }

		//FQN
		public RuleCall getParamParameterFQNParserRuleCall_2_0_1() { return cParamParameterFQNParserRuleCall_2_0_1; }
	}

	public class NodeTypeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeTypeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeTypeRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNETYPEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNodetypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNodetypeNodeTypeCrossReference_2_0 = (CrossReference)cNodetypeAssignment_2.eContents().get(0);
		private final RuleCall cNodetypeNodeTypeIDTerminalRuleCall_2_0_1 = (RuleCall)cNodetypeNodeTypeCrossReference_2_0.eContents().get(1);
		private final Assignment cPrimaryRefAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPrimaryRefPrimaryRefParserRuleCall_3_0 = (RuleCall)cPrimaryRefAssignment_3.eContents().get(0);
		
		/// **
		// * The Node context can be found with NODE if available.
		// * / NodeTypeRef returns Reference:
		//	{NodeTypeRef} "NETYPE" nodetype=[library::NodeType] primaryRef=PrimaryRef;
		public ParserRule getRule() { return rule; }

		//{NodeTypeRef} "NETYPE" nodetype=[library::NodeType] primaryRef=PrimaryRef
		public Group getGroup() { return cGroup; }

		//{NodeTypeRef}
		public Action getNodeTypeRefAction_0() { return cNodeTypeRefAction_0; }

		//"NETYPE"
		public Keyword getNETYPEKeyword_1() { return cNETYPEKeyword_1; }

		//nodetype=[library::NodeType]
		public Assignment getNodetypeAssignment_2() { return cNodetypeAssignment_2; }

		//[library::NodeType]
		public CrossReference getNodetypeNodeTypeCrossReference_2_0() { return cNodetypeNodeTypeCrossReference_2_0; }

		//ID
		public RuleCall getNodetypeNodeTypeIDTerminalRuleCall_2_0_1() { return cNodetypeNodeTypeIDTerminalRuleCall_2_0_1; }

		//primaryRef=PrimaryRef
		public Assignment getPrimaryRefAssignment_3() { return cPrimaryRefAssignment_3; }

		//PrimaryRef
		public RuleCall getPrimaryRefPrimaryRefParserRuleCall_3_0() { return cPrimaryRefPrimaryRefParserRuleCall_3_0; }
	}

	public class NodeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNodeRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cNEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNodeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cNodeNodeCrossReference_2_0 = (CrossReference)cNodeAssignment_2.eContents().get(0);
		private final RuleCall cNodeNodeIDTerminalRuleCall_2_0_1 = (RuleCall)cNodeNodeCrossReference_2_0.eContents().get(1);
		private final Assignment cPrimaryRefAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPrimaryRefPrimaryRefParserRuleCall_3_0 = (RuleCall)cPrimaryRefAssignment_3.eContents().get(0);
		
		//NodeRef returns Reference:
		//	{NodeRef} "NE" node=[operator::Node] primaryRef=PrimaryRef;
		public ParserRule getRule() { return rule; }

		//{NodeRef} "NE" node=[operator::Node] primaryRef=PrimaryRef
		public Group getGroup() { return cGroup; }

		//{NodeRef}
		public Action getNodeRefAction_0() { return cNodeRefAction_0; }

		//"NE"
		public Keyword getNEKeyword_1() { return cNEKeyword_1; }

		//node=[operator::Node]
		public Assignment getNodeAssignment_2() { return cNodeAssignment_2; }

		//[operator::Node]
		public CrossReference getNodeNodeCrossReference_2_0() { return cNodeNodeCrossReference_2_0; }

		//ID
		public RuleCall getNodeNodeIDTerminalRuleCall_2_0_1() { return cNodeNodeIDTerminalRuleCall_2_0_1; }

		//primaryRef=PrimaryRef
		public Assignment getPrimaryRefAssignment_3() { return cPrimaryRefAssignment_3; }

		//PrimaryRef
		public RuleCall getPrimaryRefPrimaryRefParserRuleCall_3_0() { return cPrimaryRefPrimaryRefParserRuleCall_3_0; }
	}

	public class ContextRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ContextRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cContextRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cThisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cPrimaryRefAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cPrimaryRefPrimaryRefParserRuleCall_2_0_0 = (RuleCall)cPrimaryRefAssignment_2_0.eContents().get(0);
		private final Assignment cRangeRefAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cRangeRefRangeRefParserRuleCall_2_1_0 = (RuleCall)cRangeRefAssignment_2_1.eContents().get(0);
		
		/// **
		// * Contextual reference will be restricted by a container in the scope provider
		// * depending on the object representation of 'this', until implemented, all possible 
		// * references will be visible.  
		// * / ContextRef returns Reference:
		//	{ContextRef} "this" (primaryRef=PrimaryRef | rangeRef=RangeRef);
		public ParserRule getRule() { return rule; }

		//{ContextRef} "this" (primaryRef=PrimaryRef | rangeRef=RangeRef)
		public Group getGroup() { return cGroup; }

		//{ContextRef}
		public Action getContextRefAction_0() { return cContextRefAction_0; }

		//"this"
		public Keyword getThisKeyword_1() { return cThisKeyword_1; }

		//primaryRef=PrimaryRef | rangeRef=RangeRef
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//primaryRef=PrimaryRef
		public Assignment getPrimaryRefAssignment_2_0() { return cPrimaryRefAssignment_2_0; }

		//PrimaryRef
		public RuleCall getPrimaryRefPrimaryRefParserRuleCall_2_0_0() { return cPrimaryRefPrimaryRefParserRuleCall_2_0_0; }

		//rangeRef=RangeRef
		public Assignment getRangeRefAssignment_2_1() { return cRangeRefAssignment_2_1; }

		//RangeRef
		public RuleCall getRangeRefRangeRefParserRuleCall_2_1_0() { return cRangeRefRangeRefParserRuleCall_2_1_0; }
	}

	public class PrimaryRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPrimaryRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNavigationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNavigationNavigationParserRuleCall_1_0 = (RuleCall)cNavigationAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cLeafRefAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cLeafRefLeafReferenceParserRuleCall_2_1_0 = (RuleCall)cLeafRefAssignment_2_1.eContents().get(0);
		
		/// **
		// * Navigation is optional, this provides additional context to be used by the interpreter.
		// * / PrimaryRef:
		//	{PrimaryRef} navigation=Navigation? ("->" leafRef=LeafReference)?;
		public ParserRule getRule() { return rule; }

		//{PrimaryRef} navigation=Navigation? ("->" leafRef=LeafReference)?
		public Group getGroup() { return cGroup; }

		//{PrimaryRef}
		public Action getPrimaryRefAction_0() { return cPrimaryRefAction_0; }

		//navigation=Navigation?
		public Assignment getNavigationAssignment_1() { return cNavigationAssignment_1; }

		//Navigation
		public RuleCall getNavigationNavigationParserRuleCall_1_0() { return cNavigationNavigationParserRuleCall_1_0; }

		//("->" leafRef=LeafReference)?
		public Group getGroup_2() { return cGroup_2; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_2_0() { return cHyphenMinusGreaterThanSignKeyword_2_0; }

		//leafRef=LeafReference
		public Assignment getLeafRefAssignment_2_1() { return cLeafRefAssignment_2_1; }

		//LeafReference
		public RuleCall getLeafRefLeafReferenceParserRuleCall_2_1_0() { return cLeafRefLeafReferenceParserRuleCall_2_1_0; }
	}

	public class NavigationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Navigation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cNavigationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Group cGroup_2_0 = (Group)cAlternatives_2.eContents().get(0);
		private final Keyword cFUNCTIONKeyword_2_0_0 = (Keyword)cGroup_2_0.eContents().get(0);
		private final Assignment cFunctionAssignment_2_0_1 = (Assignment)cGroup_2_0.eContents().get(1);
		private final CrossReference cFunctionFunctionCrossReference_2_0_1_0 = (CrossReference)cFunctionAssignment_2_0_1.eContents().get(0);
		private final RuleCall cFunctionFunctionFQNParserRuleCall_2_0_1_0_1 = (RuleCall)cFunctionFunctionCrossReference_2_0_1_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cAlternatives_2.eContents().get(1);
		private final Keyword cEQUIPMENTKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cEquipmentAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final CrossReference cEquipmentEquipmentCrossReference_2_1_1_0 = (CrossReference)cEquipmentAssignment_2_1_1.eContents().get(0);
		private final RuleCall cEquipmentEquipmentFQNParserRuleCall_2_1_1_0_1 = (RuleCall)cEquipmentEquipmentCrossReference_2_1_1_0.eContents().get(1);
		private final Keyword cPROFILEKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Keyword cSTATUSKeyword_2_3 = (Keyword)cAlternatives_2.eContents().get(3);
		
		/// **
		// * Navigation to set explicitly the Component, or to set a Profile or a Status.
		// * / Navigation:
		//	{Navigation} "." ("FUNCTION" function=[library::Function|FQN] | "EQUIPMENT" equipment=[library::Equipment|FQN] |
		//	"PROFILE" | "STATUS");
		public ParserRule getRule() { return rule; }

		//{Navigation} "." ("FUNCTION" function=[library::Function|FQN] | "EQUIPMENT" equipment=[library::Equipment|FQN] |
		//"PROFILE" | "STATUS")
		public Group getGroup() { return cGroup; }

		//{Navigation}
		public Action getNavigationAction_0() { return cNavigationAction_0; }

		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }

		//"FUNCTION" function=[library::Function|FQN] | "EQUIPMENT" equipment=[library::Equipment|FQN] | "PROFILE" | "STATUS"
		public Alternatives getAlternatives_2() { return cAlternatives_2; }

		//"FUNCTION" function=[library::Function|FQN]
		public Group getGroup_2_0() { return cGroup_2_0; }

		//"FUNCTION"
		public Keyword getFUNCTIONKeyword_2_0_0() { return cFUNCTIONKeyword_2_0_0; }

		//function=[library::Function|FQN]
		public Assignment getFunctionAssignment_2_0_1() { return cFunctionAssignment_2_0_1; }

		//[library::Function|FQN]
		public CrossReference getFunctionFunctionCrossReference_2_0_1_0() { return cFunctionFunctionCrossReference_2_0_1_0; }

		//FQN
		public RuleCall getFunctionFunctionFQNParserRuleCall_2_0_1_0_1() { return cFunctionFunctionFQNParserRuleCall_2_0_1_0_1; }

		//"EQUIPMENT" equipment=[library::Equipment|FQN]
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"EQUIPMENT"
		public Keyword getEQUIPMENTKeyword_2_1_0() { return cEQUIPMENTKeyword_2_1_0; }

		//equipment=[library::Equipment|FQN]
		public Assignment getEquipmentAssignment_2_1_1() { return cEquipmentAssignment_2_1_1; }

		//[library::Equipment|FQN]
		public CrossReference getEquipmentEquipmentCrossReference_2_1_1_0() { return cEquipmentEquipmentCrossReference_2_1_1_0; }

		//FQN
		public RuleCall getEquipmentEquipmentFQNParserRuleCall_2_1_1_0_1() { return cEquipmentEquipmentFQNParserRuleCall_2_1_1_0_1; }

		//"PROFILE"
		public Keyword getPROFILEKeyword_2_2() { return cPROFILEKeyword_2_2; }

		//"STATUS"
		public Keyword getSTATUSKeyword_2_3() { return cSTATUSKeyword_2_3; }
	}

	public class LeafReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LeafReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cResourceRefParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLinkRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStatusRefParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//LeafReference:
		//	ResourceRef | LinkRef | StatusRef;
		public ParserRule getRule() { return rule; }

		//ResourceRef | LinkRef | StatusRef
		public Alternatives getAlternatives() { return cAlternatives; }

		//ResourceRef
		public RuleCall getResourceRefParserRuleCall_0() { return cResourceRefParserRuleCall_0; }

		//LinkRef
		public RuleCall getLinkRefParserRuleCall_1() { return cLinkRefParserRuleCall_1; }

		//StatusRef
		public RuleCall getStatusRefParserRuleCall_2() { return cStatusRefParserRuleCall_2; }
	}

	public class ResourceRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ResourceRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cResourceRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRESOURCEKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cResourceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cResourceBaseResourceCrossReference_2_0 = (CrossReference)cResourceAssignment_2.eContents().get(0);
		private final RuleCall cResourceBaseResourceFQNParserRuleCall_2_0_1 = (RuleCall)cResourceBaseResourceCrossReference_2_0.eContents().get(1);
		private final Assignment cAllAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final Keyword cAllALLKeyword_3_0 = (Keyword)cAllAssignment_3.eContents().get(0);
		private final Assignment cRangeRefAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRangeRefRangeRefParserRuleCall_4_0 = (RuleCall)cRangeRefAssignment_4.eContents().get(0);
		
		//ResourceRef returns LeafReference:
		//	{ResourceRef} "RESOURCE" resource=[library::BaseResource|FQN] all?="ALL"? rangeRef=RangeRef;
		public ParserRule getRule() { return rule; }

		//{ResourceRef} "RESOURCE" resource=[library::BaseResource|FQN] all?="ALL"? rangeRef=RangeRef
		public Group getGroup() { return cGroup; }

		//{ResourceRef}
		public Action getResourceRefAction_0() { return cResourceRefAction_0; }

		//"RESOURCE"
		public Keyword getRESOURCEKeyword_1() { return cRESOURCEKeyword_1; }

		//resource=[library::BaseResource|FQN]
		public Assignment getResourceAssignment_2() { return cResourceAssignment_2; }

		//[library::BaseResource|FQN]
		public CrossReference getResourceBaseResourceCrossReference_2_0() { return cResourceBaseResourceCrossReference_2_0; }

		//FQN
		public RuleCall getResourceBaseResourceFQNParserRuleCall_2_0_1() { return cResourceBaseResourceFQNParserRuleCall_2_0_1; }

		//all?="ALL"?
		public Assignment getAllAssignment_3() { return cAllAssignment_3; }

		//"ALL"
		public Keyword getAllALLKeyword_3_0() { return cAllALLKeyword_3_0; }

		//rangeRef=RangeRef
		public Assignment getRangeRefAssignment_4() { return cRangeRefAssignment_4; }

		//RangeRef
		public RuleCall getRangeRefRangeRefParserRuleCall_4_0() { return cRangeRefRangeRefParserRuleCall_4_0; }
	}

	public class StatusRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "StatusRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cStatusRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cTolerancelevelAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTolerancelevelToleranceLevelEnumRuleCall_1_0 = (RuleCall)cTolerancelevelAssignment_1.eContents().get(0);
		
		//StatusRef returns LeafReference:
		//	{StatusRef} tolerancelevel=ToleranceLevel;
		public ParserRule getRule() { return rule; }

		//{StatusRef} tolerancelevel=ToleranceLevel
		public Group getGroup() { return cGroup; }

		//{StatusRef}
		public Action getStatusRefAction_0() { return cStatusRefAction_0; }

		//tolerancelevel=ToleranceLevel
		public Assignment getTolerancelevelAssignment_1() { return cTolerancelevelAssignment_1; }

		//ToleranceLevel
		public RuleCall getTolerancelevelToleranceLevelEnumRuleCall_1_0() { return cTolerancelevelToleranceLevelEnumRuleCall_1_0; }
	}

	public class RangeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "RangeRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValuerangeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValuerangeValueRangeEnumRuleCall_0_0 = (RuleCall)cValuerangeAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKindValueKindEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		private final Assignment cIntervalAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIntervalIntervalParserRuleCall_2_0 = (RuleCall)cIntervalAssignment_2.eContents().get(0);
		
		/// **
		// * Optional value kind AVG / BH
		// * Optional Number value (In minutes like 60, etc..)
		// * / RangeRef:
		//	valuerange=ValueRange kind=ValueKind? interval=Interval?;
		public ParserRule getRule() { return rule; }

		//valuerange=ValueRange kind=ValueKind? interval=Interval?
		public Group getGroup() { return cGroup; }

		//valuerange=ValueRange
		public Assignment getValuerangeAssignment_0() { return cValuerangeAssignment_0; }

		//ValueRange
		public RuleCall getValuerangeValueRangeEnumRuleCall_0_0() { return cValuerangeValueRangeEnumRuleCall_0_0; }

		//kind=ValueKind?
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//ValueKind
		public RuleCall getKindValueKindEnumRuleCall_1_0() { return cKindValueKindEnumRuleCall_1_0; }

		//interval=Interval?
		public Assignment getIntervalAssignment_2() { return cIntervalAssignment_2; }

		//Interval
		public RuleCall getIntervalIntervalParserRuleCall_2_0() { return cIntervalIntervalParserRuleCall_2_0; }
	}

	public class IntervalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Interval");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIntervalAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIntervalNUMBERTerminalRuleCall_0_0 = (RuleCall)cIntervalAssignment_0.eContents().get(0);
		private final Assignment cKindAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cKindIntervalKindEnumRuleCall_1_0 = (RuleCall)cKindAssignment_1.eContents().get(0);
		
		//Interval:
		//	interval=NUMBER | kind=IntervalKind;
		public ParserRule getRule() { return rule; }

		//interval=NUMBER | kind=IntervalKind
		public Alternatives getAlternatives() { return cAlternatives; }

		//interval=NUMBER
		public Assignment getIntervalAssignment_0() { return cIntervalAssignment_0; }

		//NUMBER
		public RuleCall getIntervalNUMBERTerminalRuleCall_0_0() { return cIntervalNUMBERTerminalRuleCall_0_0; }

		//kind=IntervalKind
		public Assignment getKindAssignment_1() { return cKindAssignment_1; }

		//IntervalKind
		public RuleCall getKindIntervalKindEnumRuleCall_1_0() { return cKindIntervalKindEnumRuleCall_1_0; }
	}

	public class LinkRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LinkRef");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLinkRefAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLINKKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLinkAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cLinkRelationshipCrossReference_2_0 = (CrossReference)cLinkAssignment_2.eContents().get(0);
		private final RuleCall cLinkRelationshipIDTerminalRuleCall_2_0_1 = (RuleCall)cLinkRelationshipCrossReference_2_0.eContents().get(1);
		
		/// **
		// * TODO, through a link, we should be able to access, the opposite node and 
		// * resources. 
		// * 
		// * / LinkRef returns LeafReference:
		//	{LinkRef} "LINK" link=[operator::Relationship];
		public ParserRule getRule() { return rule; }

		//{LinkRef} "LINK" link=[operator::Relationship]
		public Group getGroup() { return cGroup; }

		//{LinkRef}
		public Action getLinkRefAction_0() { return cLinkRefAction_0; }

		//"LINK"
		public Keyword getLINKKeyword_1() { return cLINKKeyword_1; }

		//link=[operator::Relationship]
		public Assignment getLinkAssignment_2() { return cLinkAssignment_2; }

		//[operator::Relationship]
		public CrossReference getLinkRelationshipCrossReference_2_0() { return cLinkRelationshipCrossReference_2_0; }

		//ID
		public RuleCall getLinkRelationshipIDTerminalRuleCall_2_0_1() { return cLinkRelationshipIDTerminalRuleCall_2_0_1; }
	}

	public class FQNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FQN");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSPACED_IDParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cColonColonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSPACED_IDParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//FQN:
		//	SPACED_ID ("::" SPACED_ID)*;
		public ParserRule getRule() { return rule; }

		//SPACED_ID ("::" SPACED_ID)*
		public Group getGroup() { return cGroup; }

		//SPACED_ID
		public RuleCall getSPACED_IDParserRuleCall_0() { return cSPACED_IDParserRuleCall_0; }

		//("::" SPACED_ID)*
		public Group getGroup_1() { return cGroup_1; }

		//"::"
		public Keyword getColonColonKeyword_1_0() { return cColonColonKeyword_1_0; }

		//SPACED_ID
		public RuleCall getSPACED_IDParserRuleCall_1_1() { return cSPACED_IDParserRuleCall_1_1; }
	}

	public class SPACED_IDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SPACED_ID");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cNUMBERTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cNUMBERTerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		//SPACED_ID returns ecore::EString:
		//	(ID | NUMBER) (ID | NUMBER)*;
		public ParserRule getRule() { return rule; }

		//(ID | NUMBER) (ID | NUMBER)*
		public Group getGroup() { return cGroup; }

		//ID | NUMBER
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_0_0() { return cIDTerminalRuleCall_0_0; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_0_1() { return cNUMBERTerminalRuleCall_0_1; }

		//(ID | NUMBER)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }

		//NUMBER
		public RuleCall getNUMBERTerminalRuleCall_1_1() { return cNUMBERTerminalRuleCall_1_1; }
	}
	
	
	public class NativeFunctionElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "NativeFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCOUNTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCOUNTCountKeyword_0_0 = (Keyword)cCOUNTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUMEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUMSumKeyword_1_0 = (Keyword)cSUMEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMINEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMINMinKeyword_2_0 = (Keyword)cMINEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cMAXEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cMAXMaxKeyword_3_0 = (Keyword)cMAXEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMEANEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMEANMeanKeyword_4_0 = (Keyword)cMEANEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cDEVIATIONEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cDEVIATIONDeviationKeyword_5_0 = (Keyword)cDEVIATIONEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cERLANGBEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cERLANGBErlangBKeyword_6_0 = (Keyword)cERLANGBEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cCLEAREnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cCLEARClearKeyword_7_0 = (Keyword)cCLEAREnumLiteralDeclaration_7.eContents().get(0);
		
		//enum NativeFunction:
		//	COUNT="count()" | SUM="sum()" | MIN="min()" | MAX="max()" | MEAN="mean()" | DEVIATION="deviation()" |
		//	ERLANGB="erlangB()" | CLEAR="clear()";
		public EnumRule getRule() { return rule; }

		//COUNT="count()" | SUM="sum()" | MIN="min()" | MAX="max()" | MEAN="mean()" | DEVIATION="deviation()" |
		//ERLANGB="erlangB()" | CLEAR="clear()"
		public Alternatives getAlternatives() { return cAlternatives; }

		//COUNT="count()"
		public EnumLiteralDeclaration getCOUNTEnumLiteralDeclaration_0() { return cCOUNTEnumLiteralDeclaration_0; }

		//"count()"
		public Keyword getCOUNTCountKeyword_0_0() { return cCOUNTCountKeyword_0_0; }

		//SUM="sum()"
		public EnumLiteralDeclaration getSUMEnumLiteralDeclaration_1() { return cSUMEnumLiteralDeclaration_1; }

		//"sum()"
		public Keyword getSUMSumKeyword_1_0() { return cSUMSumKeyword_1_0; }

		//MIN="min()"
		public EnumLiteralDeclaration getMINEnumLiteralDeclaration_2() { return cMINEnumLiteralDeclaration_2; }

		//"min()"
		public Keyword getMINMinKeyword_2_0() { return cMINMinKeyword_2_0; }

		//MAX="max()"
		public EnumLiteralDeclaration getMAXEnumLiteralDeclaration_3() { return cMAXEnumLiteralDeclaration_3; }

		//"max()"
		public Keyword getMAXMaxKeyword_3_0() { return cMAXMaxKeyword_3_0; }

		//MEAN="mean()"
		public EnumLiteralDeclaration getMEANEnumLiteralDeclaration_4() { return cMEANEnumLiteralDeclaration_4; }

		//"mean()"
		public Keyword getMEANMeanKeyword_4_0() { return cMEANMeanKeyword_4_0; }

		//DEVIATION="deviation()"
		public EnumLiteralDeclaration getDEVIATIONEnumLiteralDeclaration_5() { return cDEVIATIONEnumLiteralDeclaration_5; }

		//"deviation()"
		public Keyword getDEVIATIONDeviationKeyword_5_0() { return cDEVIATIONDeviationKeyword_5_0; }

		//ERLANGB="erlangB()"
		public EnumLiteralDeclaration getERLANGBEnumLiteralDeclaration_6() { return cERLANGBEnumLiteralDeclaration_6; }

		//"erlangB()"
		public Keyword getERLANGBErlangBKeyword_6_0() { return cERLANGBErlangBKeyword_6_0; }

		//CLEAR="clear()"
		public EnumLiteralDeclaration getCLEAREnumLiteralDeclaration_7() { return cCLEAREnumLiteralDeclaration_7; }

		//"clear()"
		public Keyword getCLEARClearKeyword_7_0() { return cCLEARClearKeyword_7_0; }
	}

	public class IntervalKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "IntervalKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMONTHEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMONTHMONTHKeyword_0_0 = (Keyword)cMONTHEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cWEEKEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cWEEKWEEKKeyword_1_0 = (Keyword)cWEEKEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cDAYEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cDAYDAYKeyword_2_0 = (Keyword)cDAYEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cHOUREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cHOURHOURKeyword_3_0 = (Keyword)cHOUREnumLiteralDeclaration_3.eContents().get(0);
		
		//enum IntervalKind:
		//	MONTH | WEEK | DAY | HOUR;
		public EnumRule getRule() { return rule; }

		//MONTH | WEEK | DAY | HOUR
		public Alternatives getAlternatives() { return cAlternatives; }

		//MONTH
		public EnumLiteralDeclaration getMONTHEnumLiteralDeclaration_0() { return cMONTHEnumLiteralDeclaration_0; }

		//"MONTH"
		public Keyword getMONTHMONTHKeyword_0_0() { return cMONTHMONTHKeyword_0_0; }

		//WEEK
		public EnumLiteralDeclaration getWEEKEnumLiteralDeclaration_1() { return cWEEKEnumLiteralDeclaration_1; }

		//"WEEK"
		public Keyword getWEEKWEEKKeyword_1_0() { return cWEEKWEEKKeyword_1_0; }

		//DAY
		public EnumLiteralDeclaration getDAYEnumLiteralDeclaration_2() { return cDAYEnumLiteralDeclaration_2; }

		//"DAY"
		public Keyword getDAYDAYKeyword_2_0() { return cDAYDAYKeyword_2_0; }

		//HOUR
		public EnumLiteralDeclaration getHOUREnumLiteralDeclaration_3() { return cHOUREnumLiteralDeclaration_3; }

		//"HOUR"
		public Keyword getHOURHOURKeyword_3_0() { return cHOURHOURKeyword_3_0; }
	}

	public class ToleranceLevelElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ToleranceLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cREDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cREDREDKeyword_0_0 = (Keyword)cREDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cAMBEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cAMBERAMBERKeyword_1_0 = (Keyword)cAMBEREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cGREENEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cGREENGREENKeyword_2_0 = (Keyword)cGREENEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cYELLOWEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cYELLOWYELLOWKeyword_3_0 = (Keyword)cYELLOWEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ToleranceLevel:
		//	RED | AMBER | GREEN | YELLOW;
		public EnumRule getRule() { return rule; }

		//RED | AMBER | GREEN | YELLOW
		public Alternatives getAlternatives() { return cAlternatives; }

		//RED
		public EnumLiteralDeclaration getREDEnumLiteralDeclaration_0() { return cREDEnumLiteralDeclaration_0; }

		//"RED"
		public Keyword getREDREDKeyword_0_0() { return cREDREDKeyword_0_0; }

		//AMBER
		public EnumLiteralDeclaration getAMBEREnumLiteralDeclaration_1() { return cAMBEREnumLiteralDeclaration_1; }

		//"AMBER"
		public Keyword getAMBERAMBERKeyword_1_0() { return cAMBERAMBERKeyword_1_0; }

		//GREEN
		public EnumLiteralDeclaration getGREENEnumLiteralDeclaration_2() { return cGREENEnumLiteralDeclaration_2; }

		//"GREEN"
		public Keyword getGREENGREENKeyword_2_0() { return cGREENGREENKeyword_2_0; }

		//YELLOW
		public EnumLiteralDeclaration getYELLOWEnumLiteralDeclaration_3() { return cYELLOWEnumLiteralDeclaration_3; }

		//"YELLOW"
		public Keyword getYELLOWYELLOWKeyword_3_0() { return cYELLOWYELLOWKeyword_3_0; }
	}

	public class ValueRangeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ValueRange");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMETRICEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMETRICMETRICKeyword_0_0 = (Keyword)cMETRICEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCAPEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCAPCAPKeyword_1_0 = (Keyword)cCAPEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cFORECASTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cFORECASTFORECASTKeyword_2_0 = (Keyword)cFORECASTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cFORECAST_CAPEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cFORECAST_CAPFORECAST_CAPKeyword_3_0 = (Keyword)cFORECAST_CAPEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTRENDEDEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTRENDEDTRENDEDKeyword_4_0 = (Keyword)cTRENDEDEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cUTILIZATIONEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cUTILIZATIONUTILIZATIONKeyword_5_0 = (Keyword)cUTILIZATIONEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cTOLERANCEEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cTOLERANCETOLERANCEKeyword_6_0 = (Keyword)cTOLERANCEEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cDERIVEDEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cDERIVEDDERIVEDKeyword_7_0 = (Keyword)cDERIVEDEnumLiteralDeclaration_7.eContents().get(0);
		
		//enum ValueRange:
		//	METRIC | CAP | FORECAST | FORECAST_CAP | TRENDED | UTILIZATION | TOLERANCE | DERIVED;
		public EnumRule getRule() { return rule; }

		//METRIC | CAP | FORECAST | FORECAST_CAP | TRENDED | UTILIZATION | TOLERANCE | DERIVED
		public Alternatives getAlternatives() { return cAlternatives; }

		//METRIC
		public EnumLiteralDeclaration getMETRICEnumLiteralDeclaration_0() { return cMETRICEnumLiteralDeclaration_0; }

		//"METRIC"
		public Keyword getMETRICMETRICKeyword_0_0() { return cMETRICMETRICKeyword_0_0; }

		//CAP
		public EnumLiteralDeclaration getCAPEnumLiteralDeclaration_1() { return cCAPEnumLiteralDeclaration_1; }

		//"CAP"
		public Keyword getCAPCAPKeyword_1_0() { return cCAPCAPKeyword_1_0; }

		//FORECAST
		public EnumLiteralDeclaration getFORECASTEnumLiteralDeclaration_2() { return cFORECASTEnumLiteralDeclaration_2; }

		//"FORECAST"
		public Keyword getFORECASTFORECASTKeyword_2_0() { return cFORECASTFORECASTKeyword_2_0; }

		//FORECAST_CAP
		public EnumLiteralDeclaration getFORECAST_CAPEnumLiteralDeclaration_3() { return cFORECAST_CAPEnumLiteralDeclaration_3; }

		//"FORECAST_CAP"
		public Keyword getFORECAST_CAPFORECAST_CAPKeyword_3_0() { return cFORECAST_CAPFORECAST_CAPKeyword_3_0; }

		//TRENDED
		public EnumLiteralDeclaration getTRENDEDEnumLiteralDeclaration_4() { return cTRENDEDEnumLiteralDeclaration_4; }

		//"TRENDED"
		public Keyword getTRENDEDTRENDEDKeyword_4_0() { return cTRENDEDTRENDEDKeyword_4_0; }

		//UTILIZATION
		public EnumLiteralDeclaration getUTILIZATIONEnumLiteralDeclaration_5() { return cUTILIZATIONEnumLiteralDeclaration_5; }

		//"UTILIZATION"
		public Keyword getUTILIZATIONUTILIZATIONKeyword_5_0() { return cUTILIZATIONUTILIZATIONKeyword_5_0; }

		//TOLERANCE
		public EnumLiteralDeclaration getTOLERANCEEnumLiteralDeclaration_6() { return cTOLERANCEEnumLiteralDeclaration_6; }

		//"TOLERANCE"
		public Keyword getTOLERANCETOLERANCEKeyword_6_0() { return cTOLERANCETOLERANCEKeyword_6_0; }

		//DERIVED
		public EnumLiteralDeclaration getDERIVEDEnumLiteralDeclaration_7() { return cDERIVEDEnumLiteralDeclaration_7; }

		//"DERIVED"
		public Keyword getDERIVEDDERIVEDKeyword_7_0() { return cDERIVEDDERIVEDKeyword_7_0; }
	}

	public class ValueKindElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ValueKind");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAVGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAVGAVGKeyword_0_0 = (Keyword)cAVGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBHEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBHBHKeyword_1_0 = (Keyword)cBHEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum ValueKind:
		//	AVG | BH;
		public EnumRule getRule() { return rule; }

		//AVG | BH
		public Alternatives getAlternatives() { return cAlternatives; }

		//AVG
		public EnumLiteralDeclaration getAVGEnumLiteralDeclaration_0() { return cAVGEnumLiteralDeclaration_0; }

		//"AVG"
		public Keyword getAVGAVGKeyword_0_0() { return cAVGAVGKeyword_0_0; }

		//BH
		public EnumLiteralDeclaration getBHEnumLiteralDeclaration_1() { return cBHEnumLiteralDeclaration_1; }

		//"BH"
		public Keyword getBHBHKeyword_1_0() { return cBHBHKeyword_1_0; }
	}
	
	private ModElements pMod;
	private ImportElements pImport;
	private FunctionElements pFunction;
	private ArgumentElements pArgument;
	private AbstractVarOrArgumentElements pAbstractVarOrArgument;
	private AbstractFunctionElements pAbstractFunction;
	private BlockElements pBlock;
	private StatementElements pStatement;
	private ReturnStatementElements pReturnStatement;
	private IfStatementElements pIfStatement;
	private WhileStatementElements pWhileStatement;
	private VariableStatementElements pVariableStatement;
	private AssignmentStatementElements pAssignmentStatement;
	private PlusAssignmentStatementElements pPlusAssignmentStatement;
	private ReferenceAssignmentStatementElements pReferenceAssignmentStatement;
	private ExpressionElements pExpression;
	private LogicalElements pLogical;
	private EqualityElements pEquality;
	private ComparisonElements pComparison;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private UnaryElements pUnary;
	private UnaryOperatorElements pUnaryOperator;
	private NativeExpressionElements pNativeExpression;
	private PrimaryExpressionElements pPrimaryExpression;
	private LiteralElements pLiteral;
	private NumberLiteralElements pNumberLiteral;
	private RangeLiteralElements pRangeLiteral;
	private FunctionCallElements pFunctionCall;
	private IndexedCallElements pIndexedCall;
	private VarOrArgumentCallElements pVarOrArgumentCall;
	private ParenthesizedExpressionElements pParenthesizedExpression;
	private NativeFunctionElements unknownRuleNativeFunction;
	private ReferenceElements pReference;
	private ParamRefElements pParamRef;
	private NodeTypeRefElements pNodeTypeRef;
	private NodeRefElements pNodeRef;
	private ContextRefElements pContextRef;
	private PrimaryRefElements pPrimaryRef;
	private NavigationElements pNavigation;
	private LeafReferenceElements pLeafReference;
	private ResourceRefElements pResourceRef;
	private StatusRefElements pStatusRef;
	private RangeRefElements pRangeRef;
	private IntervalElements pInterval;
	private IntervalKindElements unknownRuleIntervalKind;
	private ToleranceLevelElements unknownRuleToleranceLevel;
	private ValueRangeElements unknownRuleValueRange;
	private ValueKindElements unknownRuleValueKind;
	private LinkRefElements pLinkRef;
	private FQNElements pFQN;
	private SPACED_IDElements pSPACED_ID;
	private TerminalRule tNUMBER;
	private TerminalRule tINT;
	private TerminalRule tID;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public NetxscriptGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Mod:
	//	("mod" name=ID)? imports+=Import* (functions+=Function+ | statements+=Statement+);
	public ModElements getModAccess() {
		return (pMod != null) ? pMod : (pMod = new ModElements());
	}
	
	public ParserRule getModRule() {
		return getModAccess().getRule();
	}

	//Import:
	//	"import" importURI=STRING;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	//Function:
	//	"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block;
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//Argument:
	//	name=ID;
	public ArgumentElements getArgumentAccess() {
		return (pArgument != null) ? pArgument : (pArgument = new ArgumentElements());
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}

	//AbstractVarOrArgument:
	//	VariableStatement | Argument;
	public AbstractVarOrArgumentElements getAbstractVarOrArgumentAccess() {
		return (pAbstractVarOrArgument != null) ? pAbstractVarOrArgument : (pAbstractVarOrArgument = new AbstractVarOrArgumentElements());
	}
	
	public ParserRule getAbstractVarOrArgumentRule() {
		return getAbstractVarOrArgumentAccess().getRule();
	}

	//AbstractFunction:
	//	Function;
	public AbstractFunctionElements getAbstractFunctionAccess() {
		return (pAbstractFunction != null) ? pAbstractFunction : (pAbstractFunction = new AbstractFunctionElements());
	}
	
	public ParserRule getAbstractFunctionRule() {
		return getAbstractFunctionAccess().getRule();
	}

	//Block:
	//	{Block} "{" statements+=Statement* "}";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//Statement:
	//	(VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | ReturnStatement)
	//	";" | IfStatement | WhileStatement | Block;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//ReturnStatement returns Statement:
	//	{Return} "return" expression=Expression?;
	public ReturnStatementElements getReturnStatementAccess() {
		return (pReturnStatement != null) ? pReturnStatement : (pReturnStatement = new ReturnStatementElements());
	}
	
	public ParserRule getReturnStatementRule() {
		return getReturnStatementAccess().getRule();
	}

	//IfStatement returns Statement:
	//	{If} "if" "(" if=Logical ")" then=Block ("else" else=Block)?;
	public IfStatementElements getIfStatementAccess() {
		return (pIfStatement != null) ? pIfStatement : (pIfStatement = new IfStatementElements());
	}
	
	public ParserRule getIfStatementRule() {
		return getIfStatementAccess().getRule();
	}

	//WhileStatement returns Statement:
	//	{While} "while" "(" predicate=Logical ")" body=Block;
	public WhileStatementElements getWhileStatementAccess() {
		return (pWhileStatement != null) ? pWhileStatement : (pWhileStatement = new WhileStatementElements());
	}
	
	public ParserRule getWhileStatementRule() {
		return getWhileStatementAccess().getRule();
	}

	//VariableStatement returns Statement:
	//	{Variable} "var" name=ID ("=" expression=Expression)?;
	public VariableStatementElements getVariableStatementAccess() {
		return (pVariableStatement != null) ? pVariableStatement : (pVariableStatement = new VariableStatementElements());
	}
	
	public ParserRule getVariableStatementRule() {
		return getVariableStatementAccess().getRule();
	}

	//AssignmentStatement returns Statement:
	//	{Assignment} var=[AbstractVarOrArgument] "=" expression=Expression;
	public AssignmentStatementElements getAssignmentStatementAccess() {
		return (pAssignmentStatement != null) ? pAssignmentStatement : (pAssignmentStatement = new AssignmentStatementElements());
	}
	
	public ParserRule getAssignmentStatementRule() {
		return getAssignmentStatementAccess().getRule();
	}

	//PlusAssignmentStatement returns Statement:
	//	{PlusAssignment} var=[AbstractVarOrArgument] "+=" expression=Expression;
	public PlusAssignmentStatementElements getPlusAssignmentStatementAccess() {
		return (pPlusAssignmentStatement != null) ? pPlusAssignmentStatement : (pPlusAssignmentStatement = new PlusAssignmentStatementElements());
	}
	
	public ParserRule getPlusAssignmentStatementRule() {
		return getPlusAssignmentStatementAccess().getRule();
	}

	//ReferenceAssignmentStatement returns Statement:
	//	{RefAssignment} assignmentRef=(ContextRef | NodeTypeRef) "=" expression=Expression;
	public ReferenceAssignmentStatementElements getReferenceAssignmentStatementAccess() {
		return (pReferenceAssignmentStatement != null) ? pReferenceAssignmentStatement : (pReferenceAssignmentStatement = new ReferenceAssignmentStatementElements());
	}
	
	public ParserRule getReferenceAssignmentStatementRule() {
		return getReferenceAssignmentStatementAccess().getRule();
	}

	//// Expression, all operators extend this class. 
	//Expression:
	//	Logical;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// Logical	
	//Logical returns Expression:
	//	Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*;
	public LogicalElements getLogicalAccess() {
		return (pLogical != null) ? pLogical : (pLogical = new LogicalElements());
	}
	
	public ParserRule getLogicalRule() {
		return getLogicalAccess().getRule();
	}

	//// Equal, Non-Equal 
	//Equality returns Expression:
	//	Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*;
	public EqualityElements getEqualityAccess() {
		return (pEquality != null) ? pEquality : (pEquality = new EqualityElements());
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}

	//// Lesser, Greater. 
	//Comparison returns Expression:
	//	Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
	//	{GreaterEqual.left=current} ">=") right=Addition)*;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//Addition returns Expression:
	//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns Expression:
	//	Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//// Unaries are return type specific. The type on the right should be checked.  
	//Unary returns Expression:
	//	NativeExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary;
	public UnaryElements getUnaryAccess() {
		return (pUnary != null) ? pUnary : (pUnary = new UnaryElements());
	}
	
	public ParserRule getUnaryRule() {
		return getUnaryAccess().getRule();
	}

	//UnaryOperator:
	//	"-" | "+";
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return (pUnaryOperator != null) ? pUnaryOperator : (pUnaryOperator = new UnaryOperatorElements());
	}
	
	public ParserRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	/// *
	// *  Nested native functions. 
	// * / NativeExpression returns Expression:
	//	PrimaryExpression ({NativeExpression.left=current} "." nativeFunction=NativeFunction)*;
	public NativeExpressionElements getNativeExpressionAccess() {
		return (pNativeExpression != null) ? pNativeExpression : (pNativeExpression = new NativeExpressionElements());
	}
	
	public ParserRule getNativeExpressionRule() {
		return getNativeExpressionAccess().getRule();
	}

	//// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
	//PrimaryExpression returns Expression:
	//	Literal | RangeLiteral | Reference | FunctionCall | IndexedCall | ParenthesizedExpression;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//Literal returns Expression:
	//	NumberLiteral | {BooleanLiteral} (condition?="true" | "false");
	public LiteralElements getLiteralAccess() {
		return (pLiteral != null) ? pLiteral : (pLiteral = new LiteralElements());
	}
	
	public ParserRule getLiteralRule() {
		return getLiteralAccess().getRule();
	}

	//NumberLiteral:
	//	{NumberLiteral} value=NUMBER;
	public NumberLiteralElements getNumberLiteralAccess() {
		return (pNumberLiteral != null) ? pNumberLiteral : (pNumberLiteral = new NumberLiteralElements());
	}
	
	public ParserRule getNumberLiteralRule() {
		return getNumberLiteralAccess().getRule();
	}

	////RangeExpression returns Expression:
	////	'['  Expression ']';
	//RangeLiteral:
	//	{RangeLiteral} "[" (values+=NUMBER ("," values+=NUMBER)*)? "]";
	public RangeLiteralElements getRangeLiteralAccess() {
		return (pRangeLiteral != null) ? pRangeLiteral : (pRangeLiteral = new RangeLiteralElements());
	}
	
	public ParserRule getRangeLiteralRule() {
		return getRangeLiteralAccess().getRule();
	}

	//FunctionCall returns Expression:
	//	{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")";
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//IndexedCall returns Expression:
	//	VarOrArgumentCall ("[" index=Expression "]")?;
	public IndexedCallElements getIndexedCallAccess() {
		return (pIndexedCall != null) ? pIndexedCall : (pIndexedCall = new IndexedCallElements());
	}
	
	public ParserRule getIndexedCallRule() {
		return getIndexedCallAccess().getRule();
	}

	//VarOrArgumentCall returns Expression:
	//	{VarOrArgumentCall} call=[AbstractVarOrArgument];
	public VarOrArgumentCallElements getVarOrArgumentCallAccess() {
		return (pVarOrArgumentCall != null) ? pVarOrArgumentCall : (pVarOrArgumentCall = new VarOrArgumentCallElements());
	}
	
	public ParserRule getVarOrArgumentCallRule() {
		return getVarOrArgumentCallAccess().getRule();
	}

	//ParenthesizedExpression returns Expression:
	//	"(" Expression ")";
	public ParenthesizedExpressionElements getParenthesizedExpressionAccess() {
		return (pParenthesizedExpression != null) ? pParenthesizedExpression : (pParenthesizedExpression = new ParenthesizedExpressionElements());
	}
	
	public ParserRule getParenthesizedExpressionRule() {
		return getParenthesizedExpressionAccess().getRule();
	}

	//enum NativeFunction:
	//	COUNT="count()" | SUM="sum()" | MIN="min()" | MAX="max()" | MEAN="mean()" | DEVIATION="deviation()" |
	//	ERLANGB="erlangB()" | CLEAR="clear()";
	public NativeFunctionElements getNativeFunctionAccess() {
		return (unknownRuleNativeFunction != null) ? unknownRuleNativeFunction : (unknownRuleNativeFunction = new NativeFunctionElements());
	}
	
	public EnumRule getNativeFunctionRule() {
		return getNativeFunctionAccess().getRule();
	}

	/// *
	// * References return values by references to our external model. 
	// * This can be single or ranges of values. The types returned will be limited
	// * to single numerical or ranges of Value types. A Reference extends an Expression
	// * so can participate in statements having expressions. 
	// * / Reference returns Expression:
	//	ContextRef | NodeTypeRef | NodeRef | ParamRef;
	public ReferenceElements getReferenceAccess() {
		return (pReference != null) ? pReference : (pReference = new ReferenceElements());
	}
	
	public ParserRule getReferenceRule() {
		return getReferenceAccess().getRule();
	}

	/// **
	// * Single numerical value reference. 
	// * / ParamRef returns Reference:
	//	{ParamRef} "PARAM" param=[library::Parameter|FQN];
	public ParamRefElements getParamRefAccess() {
		return (pParamRef != null) ? pParamRef : (pParamRef = new ParamRefElements());
	}
	
	public ParserRule getParamRefRule() {
		return getParamRefAccess().getRule();
	}

	/// **
	// * The Node context can be found with NODE if available.
	// * / NodeTypeRef returns Reference:
	//	{NodeTypeRef} "NETYPE" nodetype=[library::NodeType] primaryRef=PrimaryRef;
	public NodeTypeRefElements getNodeTypeRefAccess() {
		return (pNodeTypeRef != null) ? pNodeTypeRef : (pNodeTypeRef = new NodeTypeRefElements());
	}
	
	public ParserRule getNodeTypeRefRule() {
		return getNodeTypeRefAccess().getRule();
	}

	//NodeRef returns Reference:
	//	{NodeRef} "NE" node=[operator::Node] primaryRef=PrimaryRef;
	public NodeRefElements getNodeRefAccess() {
		return (pNodeRef != null) ? pNodeRef : (pNodeRef = new NodeRefElements());
	}
	
	public ParserRule getNodeRefRule() {
		return getNodeRefAccess().getRule();
	}

	/// **
	// * Contextual reference will be restricted by a container in the scope provider
	// * depending on the object representation of 'this', until implemented, all possible 
	// * references will be visible.  
	// * / ContextRef returns Reference:
	//	{ContextRef} "this" (primaryRef=PrimaryRef | rangeRef=RangeRef);
	public ContextRefElements getContextRefAccess() {
		return (pContextRef != null) ? pContextRef : (pContextRef = new ContextRefElements());
	}
	
	public ParserRule getContextRefRule() {
		return getContextRefAccess().getRule();
	}

	/// **
	// * Navigation is optional, this provides additional context to be used by the interpreter.
	// * / PrimaryRef:
	//	{PrimaryRef} navigation=Navigation? ("->" leafRef=LeafReference)?;
	public PrimaryRefElements getPrimaryRefAccess() {
		return (pPrimaryRef != null) ? pPrimaryRef : (pPrimaryRef = new PrimaryRefElements());
	}
	
	public ParserRule getPrimaryRefRule() {
		return getPrimaryRefAccess().getRule();
	}

	/// **
	// * Navigation to set explicitly the Component, or to set a Profile or a Status.
	// * / Navigation:
	//	{Navigation} "." ("FUNCTION" function=[library::Function|FQN] | "EQUIPMENT" equipment=[library::Equipment|FQN] |
	//	"PROFILE" | "STATUS");
	public NavigationElements getNavigationAccess() {
		return (pNavigation != null) ? pNavigation : (pNavigation = new NavigationElements());
	}
	
	public ParserRule getNavigationRule() {
		return getNavigationAccess().getRule();
	}

	//LeafReference:
	//	ResourceRef | LinkRef | StatusRef;
	public LeafReferenceElements getLeafReferenceAccess() {
		return (pLeafReference != null) ? pLeafReference : (pLeafReference = new LeafReferenceElements());
	}
	
	public ParserRule getLeafReferenceRule() {
		return getLeafReferenceAccess().getRule();
	}

	//ResourceRef returns LeafReference:
	//	{ResourceRef} "RESOURCE" resource=[library::BaseResource|FQN] all?="ALL"? rangeRef=RangeRef;
	public ResourceRefElements getResourceRefAccess() {
		return (pResourceRef != null) ? pResourceRef : (pResourceRef = new ResourceRefElements());
	}
	
	public ParserRule getResourceRefRule() {
		return getResourceRefAccess().getRule();
	}

	//StatusRef returns LeafReference:
	//	{StatusRef} tolerancelevel=ToleranceLevel;
	public StatusRefElements getStatusRefAccess() {
		return (pStatusRef != null) ? pStatusRef : (pStatusRef = new StatusRefElements());
	}
	
	public ParserRule getStatusRefRule() {
		return getStatusRefAccess().getRule();
	}

	/// **
	// * Optional value kind AVG / BH
	// * Optional Number value (In minutes like 60, etc..)
	// * / RangeRef:
	//	valuerange=ValueRange kind=ValueKind? interval=Interval?;
	public RangeRefElements getRangeRefAccess() {
		return (pRangeRef != null) ? pRangeRef : (pRangeRef = new RangeRefElements());
	}
	
	public ParserRule getRangeRefRule() {
		return getRangeRefAccess().getRule();
	}

	//Interval:
	//	interval=NUMBER | kind=IntervalKind;
	public IntervalElements getIntervalAccess() {
		return (pInterval != null) ? pInterval : (pInterval = new IntervalElements());
	}
	
	public ParserRule getIntervalRule() {
		return getIntervalAccess().getRule();
	}

	//enum IntervalKind:
	//	MONTH | WEEK | DAY | HOUR;
	public IntervalKindElements getIntervalKindAccess() {
		return (unknownRuleIntervalKind != null) ? unknownRuleIntervalKind : (unknownRuleIntervalKind = new IntervalKindElements());
	}
	
	public EnumRule getIntervalKindRule() {
		return getIntervalKindAccess().getRule();
	}

	//enum ToleranceLevel:
	//	RED | AMBER | GREEN | YELLOW;
	public ToleranceLevelElements getToleranceLevelAccess() {
		return (unknownRuleToleranceLevel != null) ? unknownRuleToleranceLevel : (unknownRuleToleranceLevel = new ToleranceLevelElements());
	}
	
	public EnumRule getToleranceLevelRule() {
		return getToleranceLevelAccess().getRule();
	}

	//enum ValueRange:
	//	METRIC | CAP | FORECAST | FORECAST_CAP | TRENDED | UTILIZATION | TOLERANCE | DERIVED;
	public ValueRangeElements getValueRangeAccess() {
		return (unknownRuleValueRange != null) ? unknownRuleValueRange : (unknownRuleValueRange = new ValueRangeElements());
	}
	
	public EnumRule getValueRangeRule() {
		return getValueRangeAccess().getRule();
	}

	//enum ValueKind:
	//	AVG | BH;
	public ValueKindElements getValueKindAccess() {
		return (unknownRuleValueKind != null) ? unknownRuleValueKind : (unknownRuleValueKind = new ValueKindElements());
	}
	
	public EnumRule getValueKindRule() {
		return getValueKindAccess().getRule();
	}

	/// **
	// * TODO, through a link, we should be able to access, the opposite node and 
	// * resources. 
	// * 
	// * / LinkRef returns LeafReference:
	//	{LinkRef} "LINK" link=[operator::Relationship];
	public LinkRefElements getLinkRefAccess() {
		return (pLinkRef != null) ? pLinkRef : (pLinkRef = new LinkRefElements());
	}
	
	public ParserRule getLinkRefRule() {
		return getLinkRefAccess().getRule();
	}

	//FQN:
	//	SPACED_ID ("::" SPACED_ID)*;
	public FQNElements getFQNAccess() {
		return (pFQN != null) ? pFQN : (pFQN = new FQNElements());
	}
	
	public ParserRule getFQNRule() {
		return getFQNAccess().getRule();
	}

	//SPACED_ID returns ecore::EString:
	//	(ID | NUMBER) (ID | NUMBER)*;
	public SPACED_IDElements getSPACED_IDAccess() {
		return (pSPACED_ID != null) ? pSPACED_ID : (pSPACED_ID = new SPACED_IDElements());
	}
	
	public ParserRule getSPACED_IDRule() {
		return getSPACED_IDAccess().getRule();
	}

	//terminal NUMBER returns ecore::EBigDecimal:
	//	"0".."9"* ("." "0".."9"+)?;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//terminal INT returns ecore::EInt:
	//	"zzzzzzzzz";
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	/// *
	// * - Can have quotes and dash. 
	// * / terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_" | "-" | "(" | ")") ("a".."z" | "A".."Z" | "_" | "0".."9" | "-" | "(" | ")")*;
	public TerminalRule getIDRule() {
		return (tID != null) ? tID : (tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ID"));
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
