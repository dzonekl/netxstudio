/*******************************************************************************
NetXScript interpreter. 
Supports: 

Arithmetics
Functions
Variables
Keyword substitution, and referenced model/feature lookup.

*******************************************************************************/
grammar com.netxforge.Netxscript with org.eclipse.xtext.common.Terminals

generate netxscript "http://www.netxforge.com/Netxscript"

// Declare an alias to access ecore types. 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
// Note we can't use the nsURI, as it won't be found in development time. On the other hand the resource
// uri won't be found in runtime??? 
//import "platform:/resource/com.netxforge.model.a/model/library.ecore" as library
import "platform:/resource/com.netxforge.netxstudio.models/models/cdo/13042011/library.ecore" as library
import "platform:/resource/com.netxforge.netxstudio.models/models/cdo/13042011/operators.ecore" as operator
import "platform:/resource/com.netxforge.netxstudio.models/models/cdo/13042011/metrics.ecore" as metric

Mod:
	('mod' name=ID)?
	(imports+=Import)*
	((functions+=Function)+ |
	(statements+=Statement)+);

// TODO, DO WE NEED A CONTEXT HINT?
//Context:
//	'context' context=[ecore::EObject];

Import:
	'import' importURI=STRING;

	//ImportName:
//	ID ('.' '*')?;


// TODO, we can't have mandatory brackets, as this would conflict with our PrimaryExpression. 
Function:
	'def' name=ID '(' (args+=Argument (',' args+=Argument)*)? ')' block=Block;

Argument:
	name=ID;

AbstractVarOrArgument:
	VariableStatement | Argument;

AbstractFunction:
	Function;

Block:
	{Block} '{' statements+=Statement* '}';

Statement:
	(VariableStatement | AssignmentStatement | PlusAssignmentStatement | ReferenceAssignmentStatement | expression=Expression | ReturnStatement) ';'
	| IfStatement | WhileStatement | Block;

ReturnStatement returns Statement:
	{Return} 'return' (expression=Expression)?;

IfStatement returns Statement:
	{If} 'if' '(' if=Logical ')' then=Block ('else' else=Block)?;

WhileStatement returns Statement:
	{While} 'while' '(' predicate=Logical ')' body=Block;

VariableStatement returns Statement:
	{Variable} 'var' name=ID (('=') expression=Expression)?;

AssignmentStatement returns Statement:
	{Assignment} var=[AbstractVarOrArgument]  '='  expression=Expression;

PlusAssignmentStatement returns Statement:
	{PlusAssignment} var=[AbstractVarOrArgument]  '+='  expression=Expression;

//AssignmentStatement returns Statement:
//	VarOrArgumentCall ({IndexedAssignment.assignment=current})?  '=' expression=Expression;

ReferenceAssignmentStatement returns Statement:
	{RefAssignment} assignmentRef=(ContextRef | NodeTypeRef ) '=' expression=Expression;

	// Expression, all operators extend this class. 
Expression:
	Logical;

	// Logical	
Logical returns Expression:
	Equality (({And.left=current} '&&' | {Or.left=current} '||') right=Equality)*;

	// Equal, Non-Equal 
Equality returns Expression:
	Comparison (({Equal.left=current} '==' | {Unequal.left=current} '!=') right=Comparison)*;

	// Lesser, Greater. 
Comparison returns Expression:
	Addition (({Lesser.left=current} '<' | {LesserEqual.left=current} '<=' | {Greater.left=current} '>' |
	{GreaterEqual.left=current} '>=') right=Addition)*;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	Unary (({Multi.left=current} '*' | {Div.left=current} '/' | {Modulo.left=current} '%') right=Unary)*;

	// Unaries are return type specific. The type on the right should be checked.  
Unary returns Expression:
	PrimaryExpression | ({Negation} op='!' | {UnaryPlusMinus} op=UnaryOperator) right=Unary;

UnaryOperator:
	'-' | '+';

	// TODO, a functionCall is not necessarly an abstract definition in this grammar, but could 
// be an internal function call. For this we could mixin, a grammar which contains
// all internal calls.

// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
PrimaryExpression returns Expression:
	Literal | Range | NativeExpression | Reference | FunctionCall | IndexedCall | ParenthesizedExpression;

Literal returns Expression:
	 NumberLiteral | {BooleanLiteral} (condition?='true' | 'false');

NumberLiteral returns Expression:
	{NumberLiteral} value=NUMBER
;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

FunctionCall returns Expression:
	{FunctionCall} func=[AbstractFunction] '(' (args+=Expression (',' args+=Expression)*)? ')';

IndexedCall returns Expression:
	VarOrArgumentCall ('[' index=Expression ']')?
;

NativeExpression returns Expression:
	{NativeExpression} (range=RangeLiteral | ref=Reference | var=VarOrArgumentCall) '.' nativeFunction=NativeFunction;

VarOrArgumentCall returns Expression:
	{VarOrArgumentCall} call=[AbstractVarOrArgument] ;

Range:
	RangeLiteral;

RangeLiteral returns Range:
	{RangeLiteral} '[' (values+=NUMBER (',' values+=NUMBER)*)? ']';

enum NativeFunction:
	COUNT='count()' | SUM='sum()' | MIN='min()' | MAX='max()' | MEAN='mean()' | DEVIATION='deviation()' | ERLANGB='erlangB()' | CLEAR ='clear()';

Reference returns Expression:
	ContextRef | NodeTypeRef
;

/**
 * The Node context can be found with NODE if available.
 */
NodeTypeRef returns Reference:
	{NodeTypeRef} 'NODETYPE' nodetype=[library::NodeType] primaryRef=PrimaryRef
;

/**
 * Contextual reference will be restricted by a container in the scope provider
 * depending on the object representation of 'this', until implemented, all possible 
 * references will be visible.  
 */

ContextRef returns Reference:
	{ContextRef} 'this' (primaryRef=PrimaryRef | rangeRef=RangeRef);

/**
 * Exteral Node references, these can be nested and finish with a resource reference.
 */
 
PrimaryRef returns Reference:
	(components+=ComponentRef)+ ('->' leafRef=LeafReference)?;

ComponentRef returns Reference:
	{ComponentRef} '.' ( 'FUNCTION' function=[library::Function] | 'EQUIPMENT' equipment=[library::Equipment] | 'PROFILE' | 'STATUS')
;

//ServiceRef returns Reference:
//	{ServiceRef} () 
//;


LeafReference returns LeafReference:
	ResourceRef | LinkRef | StatusRef;

ResourceRef returns LeafReference:
	{ResourceRef} 'RESOURCE' (resource=[library::BaseResource] | 'ALL') rangeRef=RangeRef;

StatusRef returns LeafReference:
	{StatusRef} tolerancelevel=ToleranceLevel;

/**
 * Optional value kind AVG / BH
 * Optional Number value (In minutes like 60, etc..)
 * 
 */
RangeRef:
	valuerange=ValueRange (kind=ValueKind)? (interval = Interval)?
;

Interval: 
	interval=NUMBER | kind=IntervalKind
	; 

enum IntervalKind:
	MONTH="MONTH" | WEEK="WEEK" |  DAY="DAY" | HOUR="HOUR"   
;

enum ToleranceLevel:
	RED='RED' | AMBER='AMBER' | GREEN='GREEN' | YELLOW='YELLOW'
;


enum ValueRange: 
	METRIC='METRIC' | CAP='CAP' | FORECAST='FORECAST' | FORECAST_CAP='FORECAST_CAP' | TRENDED='TRENDED' | UTILIZATION='UTILIZATION'	| TOLERANCE='TOLERANCE' | DERIVED="DERIVED"
;

enum ValueKind: 
	AVG='AVG' | BH='BH'
;

/**
 * TODO, through a link, we should be able to access, the opposite node and 
 * resources. 
 * 
 */
LinkRef returns LeafReference:
	{LinkRef} 'LINK' link=[operator::Relationship];

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;

terminal INT returns ecore::EInt:
	'zzzzzzzzz';