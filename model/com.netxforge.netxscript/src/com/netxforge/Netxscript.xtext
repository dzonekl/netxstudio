/*******************************************************************************
NetXScript interpreter. 
Supports: 

Arithmetics
Functions
Variables
Keyword substitution, and referenced model/feature lookup.

*******************************************************************************/
grammar com.netxforge.Netxscript with org.eclipse.xtext.common.Terminals

generate netxscript "http://www.netxforge.com/Netxscript"

// Declare an alias to access ecore types. 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
// Note we can't use the nsURI, as it won't be found in development time. On the other hand the resource
// uri won't be found in runtime??? 
//import "platform:/resource/com.netxforge.model.a/model/library.ecore" as library
import "platform:/resource/com.netxforge.netxstudio.models/models/emf/13042011/library.ecore" as library
import "platform:/resource/com.netxforge.netxstudio.models/models/emf/13042011/operators.ecore" as operator

Mod:
	('mod' name=ID)?
	(imports+=Import)*
	((functions+=Function)+ |
	(statements+=Statement)+);

Context:
	'context' context=[ecore::EObject];

Import:
	'import' importURI=STRING;

	//ImportName:
//	ID ('.' '*')?;


// TODO, we can't have mandatory brackets, as this would conflict with our PrimaryExpression. 
Function:
	'def' name=ID '(' (args+=Argument (',' args+=Argument)*)? ')' block=Block;

Argument:
	name=ID;

AbstractVarOrArgument:
	VariableStatement | Argument;

AbstractFunction:
	Function;

Block:
	{Block} '{' statements+=Statement* '}';

Statement:
	(VariableStatement | AssignmentStatement | ReferenceAssignmentStatement | expression=Expression | ReturnStatement) ';'
	| IfStatement | WhileStatement | Block;

ReturnStatement returns Statement:
	{Return} 'return' (expression=Expression)?;

IfStatement returns Statement:
	{If} 'if' '(' if=Logical ')' then=Block ('else' else=Block)?;

WhileStatement returns Statement:
	{While} 'while' '(' predicate=Logical ')' body=Block;

VariableStatement returns Statement:
	{Variable} 'var' name=ID (('=') expression=Expression)?;

AssignmentStatement returns Statement:
	{Assignment} var=[AbstractVarOrArgument]  '=' expression=Expression;

//AssignmentStatement returns Statement:
//	VarOrArgumentCall ({IndexedAssignment.assignment=current})?  '=' expression=Expression;

ReferenceAssignmentStatement returns Statement:
	{RefAssignement} ref=ContextRef '=' expression=Expression;

	// Expression, all operators extend this class. 
Expression:
	Logical;

	// Logical	
Logical returns Expression:
	Equality (({And.left=current} '&&' | {Or.left=current} '||') right=Equality)*;

	// Equal, Non-Equal 
Equality returns Expression:
	Comparison (({Equal.left=current} '==' | {Unequal.left=current} '!=') right=Comparison)*;

	// Lesser, Greater. 
Comparison returns Expression:
	Addition (({Lesser.left=current} '<' | {LesserEqual.left=current} '<=' | {Greater.left=current} '>' |
	{GreaterEqual.left=current} '>=') right=Addition)*;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	Unary (({Multi.left=current} '*' | {Div.left=current} '/' | {Modulo.left=current} '%') right=Unary)*;

	// Unaries are return type specific. The type on the right should be checked.  
Unary returns Expression:
	PrimaryExpression | ({Negation} op='!' | {UnaryPlusMinus} op=UnaryOperator) right=Unary;

UnaryOperator:
	'-' | '+';

	// TODO, a functionCall is not necessarly an abstract definition in this grammar, but could 
// be an internal function call. For this we could mixin, a grammar which contains
// all internal calls.

// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
PrimaryExpression returns Expression:
	Literal | Range | NativeExpression | Reference | FunctionCall | IndexedCall | ParenthesizedExpression;

Literal returns Expression:
	 NumberLiteral | {BooleanLiteral} (condition?='true' | 'false');

NumberLiteral returns Expression:
	{NumberLiteral} value=NUMBER
;

ParenthesizedExpression returns Expression:
	'(' Expression ')';

FunctionCall returns Expression:
	{FunctionCall} func=[AbstractFunction] '(' (args+=Expression (',' args+=Expression)*)? ')';

IndexedCall returns Expression:
	VarOrArgumentCall ('[' index=Expression ']')?
;

VarOrArgumentCall returns Expression:
	{VarOrArgumentCall} call=[AbstractVarOrArgument] ;

NativeExpression returns Expression:
	{NativeExpression} (range=RangeLiteral | ref=Reference) '.' nativeFunction=NativeFunction;

Range:
	RangeLiteral;

RangeLiteral returns Range:
	{RangeLiteral} '[' values+=NUMBER (',' values+=NUMBER)* ']';

Reference returns Expression:
	ContextRef;

enum NativeFunction:
	COUNT='count()' | SUM='sum()' | MIN='min()' | MAX='max()' | MEAN='mean()' | DEVIATION='deviation()';

	/**
 * Contextual reference will be restricted by a container in the scope provider
 * depending on the object representation of 'this', until implemented, all possible 
 * references will be visible.  
 * 
 * TODO:
 * As an alternative to this, implement hooks into the object types, with a literal string 
 * like 'Node'  
 * 
 */
ContextRef returns Reference:
	'this' NodeRef;

	/**
 * Exteral Node references, these can be nested and finish with a resource reference.
 */
NodeRef returns Reference:
	(nodes+=PrimaryNodeRef)+ ('->' ref=LeafRef)?;

PrimaryNodeRef returns Reference:
	{NodeRef} '.' node=[library::NodeType];

LeafRef:
	ResourceRef | LinkRef;


/**
 *  TODO, for resource, we need access to the sub ranges. 
 * This could be: 
 * Res.metric.period=?
 * Res.cap
 * Res.forecast
 *
 */
ResourceRef returns Reference:
	{ResourceRef} 'Res' resource=[library::NetXResource];

/**
 * TODO, through a link, we should be able to access, the opposite node and 
 * resources. 
 * 
 */
LinkRef returns Reference:
	{LinkRef} 'Link' link=[operator::Relationship];

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;

terminal INT returns ecore::EInt:
	'this one has been deactivated';