/*
* generated by Xtext
*/
package com.netxforge.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class SmiGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Module");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdMODULE_IDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Keyword cDEFINITIONSKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cColonColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cBEGINKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAssignmentsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAssignmentsAssignmentParserRuleCall_4_0 = (RuleCall)cAssignmentsAssignment_4.eContents().get(0);
		private final Keyword cENDKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Module:
		//	id=MODULE_ID "DEFINITIONS" "::=" "BEGIN" assignments+=Assignment* "END";
		public ParserRule getRule() { return rule; }

		//id=MODULE_ID "DEFINITIONS" "::=" "BEGIN" assignments+=Assignment* "END"
		public Group getGroup() { return cGroup; }

		//id=MODULE_ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//MODULE_ID
		public RuleCall getIdMODULE_IDTerminalRuleCall_0_0() { return cIdMODULE_IDTerminalRuleCall_0_0; }

		//"DEFINITIONS"
		public Keyword getDEFINITIONSKeyword_1() { return cDEFINITIONSKeyword_1; }

		//"::="
		public Keyword getColonColonEqualsSignKeyword_2() { return cColonColonEqualsSignKeyword_2; }

		//"BEGIN"
		public Keyword getBEGINKeyword_3() { return cBEGINKeyword_3; }

		//assignments+=Assignment*
		public Assignment getAssignmentsAssignment_4() { return cAssignmentsAssignment_4; }

		//Assignment
		public RuleCall getAssignmentsAssignmentParserRuleCall_4_0() { return cAssignmentsAssignmentParserRuleCall_4_0; }

		//"END"
		public Keyword getENDKeyword_5() { return cENDKeyword_5; }
	}

	public class AssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Assignment");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cMacrosAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cMacrosMacroParserRuleCall_0_0 = (RuleCall)cMacrosAssignment_0.eContents().get(0);
		private final Assignment cTypesAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTypesValueAssignmentParserRuleCall_1_0 = (RuleCall)cTypesAssignment_1.eContents().get(0);
		private final RuleCall cObjectIdentifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Assignment:
		//	macros=Macro | types+=ValueAssignment | ObjectIdentifier;
		public ParserRule getRule() { return rule; }

		//macros=Macro | types+=ValueAssignment | ObjectIdentifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//macros=Macro
		public Assignment getMacrosAssignment_0() { return cMacrosAssignment_0; }

		//Macro
		public RuleCall getMacrosMacroParserRuleCall_0_0() { return cMacrosMacroParserRuleCall_0_0; }

		//types+=ValueAssignment
		public Assignment getTypesAssignment_1() { return cTypesAssignment_1; }

		//ValueAssignment
		public RuleCall getTypesValueAssignmentParserRuleCall_1_0() { return cTypesValueAssignmentParserRuleCall_1_0; }

		//ObjectIdentifier
		public RuleCall getObjectIdentifierParserRuleCall_2() { return cObjectIdentifierParserRuleCall_2; }
	}

	public class MacroElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Macro");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDescriptorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDescriptorMacroDescriptorParserRuleCall_0_0 = (RuleCall)cDescriptorAssignment_0.eContents().get(0);
		private final Keyword cMACROKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cColonColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cBEGINKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cTYPENOTATIONKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cTypeNotationsAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cTypeNotationsValueAssignmentCrossReference_5_0 = (CrossReference)cTypeNotationsAssignment_5.eContents().get(0);
		private final RuleCall cTypeNotationsValueAssignmentIDTerminalRuleCall_5_0_1 = (RuleCall)cTypeNotationsValueAssignmentCrossReference_5_0.eContents().get(1);
		private final Keyword cVALUENOTATIONKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cValueNotationAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cValueNotationMacroValueParserRuleCall_7_0 = (RuleCall)cValueNotationAssignment_7.eContents().get(0);
		private final Assignment cInnerTypesAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cInnerTypesValueAssignmentParserRuleCall_8_0 = (RuleCall)cInnerTypesAssignment_8.eContents().get(0);
		private final Keyword cENDKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//// Section 3.1 
		//// ...Within an information module, each macro invocation appears as:
		////
		////        <descriptor> <macro> <clauses> ::= <value>
		////
		//// where <descriptor> corresponds to an ASN.1 identifier, <macro> names
		//// the macro being invoked, and <clauses> and <value> depend on the
		//// definition of the macro. 
		//Macro:
		//	descriptor=MacroDescriptor "MACRO" "::=" "BEGIN" "TYPE NOTATION" typeNotations+=[ValueAssignment]+ // Reference one or more value assignment. 
		//	"VALUE NOTATION" valueNotation= // Define one Macro value. 
		//	MacroValue // Define 1 or more value assignment. 
		//	innerTypes+=ValueAssignment+ "END";
		public ParserRule getRule() { return rule; }

		//descriptor=MacroDescriptor "MACRO" "::=" "BEGIN" "TYPE NOTATION" typeNotations+=[ValueAssignment]+ // Reference one or more value assignment. 
		//"VALUE NOTATION" valueNotation= // Define one Macro value. 
		//MacroValue // Define 1 or more value assignment. 
		//innerTypes+=ValueAssignment+ "END"
		public Group getGroup() { return cGroup; }

		//descriptor=MacroDescriptor
		public Assignment getDescriptorAssignment_0() { return cDescriptorAssignment_0; }

		//MacroDescriptor
		public RuleCall getDescriptorMacroDescriptorParserRuleCall_0_0() { return cDescriptorMacroDescriptorParserRuleCall_0_0; }

		//"MACRO"
		public Keyword getMACROKeyword_1() { return cMACROKeyword_1; }

		//"::="
		public Keyword getColonColonEqualsSignKeyword_2() { return cColonColonEqualsSignKeyword_2; }

		//"BEGIN"
		public Keyword getBEGINKeyword_3() { return cBEGINKeyword_3; }

		//"TYPE NOTATION"
		public Keyword getTYPENOTATIONKeyword_4() { return cTYPENOTATIONKeyword_4; }

		//typeNotations+=[ValueAssignment]+
		public Assignment getTypeNotationsAssignment_5() { return cTypeNotationsAssignment_5; }

		//[ValueAssignment]
		public CrossReference getTypeNotationsValueAssignmentCrossReference_5_0() { return cTypeNotationsValueAssignmentCrossReference_5_0; }

		//ID
		public RuleCall getTypeNotationsValueAssignmentIDTerminalRuleCall_5_0_1() { return cTypeNotationsValueAssignmentIDTerminalRuleCall_5_0_1; }

		//"VALUE NOTATION"
		public Keyword getVALUENOTATIONKeyword_6() { return cVALUENOTATIONKeyword_6; }

		//valueNotation= // Define one Macro value. 
		//MacroValue
		public Assignment getValueNotationAssignment_7() { return cValueNotationAssignment_7; }

		//// Define one Macro value. 
		//MacroValue
		public RuleCall getValueNotationMacroValueParserRuleCall_7_0() { return cValueNotationMacroValueParserRuleCall_7_0; }

		//// Define 1 or more value assignment. 
		//innerTypes+=ValueAssignment+
		public Assignment getInnerTypesAssignment_8() { return cInnerTypesAssignment_8; }

		//ValueAssignment
		public RuleCall getInnerTypesValueAssignmentParserRuleCall_8_0() { return cInnerTypesValueAssignmentParserRuleCall_8_0; }

		//"END"
		public Keyword getENDKeyword_9() { return cENDKeyword_9; }
	}

	public class MacroDescriptorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroDescriptor");
		private final RuleCall cMODULE_IDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// A Descriptor for the Macro. 
		//MacroDescriptor:
		//	MODULE_ID;
		public ParserRule getRule() { return rule; }

		//MODULE_ID
		public RuleCall getMODULE_IDTerminalRuleCall() { return cMODULE_IDTerminalRuleCall; }
	}

	public class MacroValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MacroValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cMacroValueAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cValueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cTypeMACRO_VALUE_TYPEEnumRuleCall_2_0 = (RuleCall)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cANY_OTHERTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////  No description found for this :-( 
		//MacroValue:
		//	{MacroValue} "value(" type=MACRO_VALUE_TYPE? ANY_OTHER ")";
		public ParserRule getRule() { return rule; }

		//{MacroValue} "value(" type=MACRO_VALUE_TYPE? ANY_OTHER ")"
		public Group getGroup() { return cGroup; }

		//{MacroValue}
		public Action getMacroValueAction_0() { return cMacroValueAction_0; }

		//"value("
		public Keyword getValueKeyword_1() { return cValueKeyword_1; }

		//type=MACRO_VALUE_TYPE?
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//MACRO_VALUE_TYPE
		public RuleCall getTypeMACRO_VALUE_TYPEEnumRuleCall_2_0() { return cTypeMACRO_VALUE_TYPEEnumRuleCall_2_0; }

		//ANY_OTHER
		public RuleCall getANY_OTHERTerminalRuleCall_3() { return cANY_OTHERTerminalRuleCall_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class ValueAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeReferenceMODULE_IDTerminalRuleCall_0_0 = (RuleCall)cTypeReferenceAssignment_0.eContents().get(0);
		private final Keyword cColonColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueOrParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// An ASN.1 Value assignment. 
		//ValueAssignment:
		//	typeReference=MODULE_ID "::=" value=Or;
		public ParserRule getRule() { return rule; }

		//typeReference=MODULE_ID "::=" value=Or
		public Group getGroup() { return cGroup; }

		//typeReference=MODULE_ID
		public Assignment getTypeReferenceAssignment_0() { return cTypeReferenceAssignment_0; }

		//MODULE_ID
		public RuleCall getTypeReferenceMODULE_IDTerminalRuleCall_0_0() { return cTypeReferenceMODULE_IDTerminalRuleCall_0_0; }

		//"::="
		public Keyword getColonColonEqualsSignKeyword_1() { return cColonColonEqualsSignKeyword_1; }

		//value=Or
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Or
		public RuleCall getValueOrParserRuleCall_2_0() { return cValueOrParserRuleCall_2_0; }
	}

	public class OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cValueTypeParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cGroup_1.eContents().get(0);
		private final Action cOrLeftAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_0_1 = (Keyword)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightValueTypeParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Allow 'OR' on value types. 
		//Or:
		//	ValueType (({Or.left=current} "|") right=ValueType)*;
		public ParserRule getRule() { return rule; }

		//ValueType (({Or.left=current} "|") right=ValueType)*
		public Group getGroup() { return cGroup; }

		//ValueType
		public RuleCall getValueTypeParserRuleCall_0() { return cValueTypeParserRuleCall_0; }

		//(({Or.left=current} "|") right=ValueType)*
		public Group getGroup_1() { return cGroup_1; }

		//{Or.left=current} "|"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0_0() { return cOrLeftAction_1_0_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_0_1() { return cVerticalLineKeyword_1_0_1; }

		//right=ValueType
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//ValueType
		public RuleCall getRightValueTypeParserRuleCall_1_1_0() { return cRightValueTypeParserRuleCall_1_1_0; }
	}

	public class ValueTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ValueType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIA5STRINGTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final CrossReference cTypeValueAssignmentCrossReference_1_0_0 = (CrossReference)cTypeAssignment_1_0.eContents().get(0);
		private final RuleCall cTypeValueAssignmentIDTerminalRuleCall_1_0_0_1 = (RuleCall)cTypeValueAssignmentCrossReference_1_0_0.eContents().get(1);
		private final Assignment cSimpleTypeAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cSimpleTypeASN1_TYPEParserRuleCall_1_1_0 = (RuleCall)cSimpleTypeAssignment_1_1.eContents().get(0);
		
		////Choice:
		//// Notes: The name of the right handside value assignment is optional. 
		//// TODO1 Comma separated, multiple ValueAssignments
		//// Example: 
		//// IndexTypes ::=
		////                  IndexType
		////                | IndexTypes "," IndexType
		//ValueType:
		//	name=IA5STRING? (type=[ValueAssignment] | simpleType=ASN1_TYPE);
		public ParserRule getRule() { return rule; }

		//name=IA5STRING? (type=[ValueAssignment] | simpleType=ASN1_TYPE)
		public Group getGroup() { return cGroup; }

		//name=IA5STRING?
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//IA5STRING
		public RuleCall getNameIA5STRINGTerminalRuleCall_0_0() { return cNameIA5STRINGTerminalRuleCall_0_0; }

		//type=[ValueAssignment] | simpleType=ASN1_TYPE
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//type=[ValueAssignment]
		public Assignment getTypeAssignment_1_0() { return cTypeAssignment_1_0; }

		//[ValueAssignment]
		public CrossReference getTypeValueAssignmentCrossReference_1_0_0() { return cTypeValueAssignmentCrossReference_1_0_0; }

		//ID
		public RuleCall getTypeValueAssignmentIDTerminalRuleCall_1_0_0_1() { return cTypeValueAssignmentIDTerminalRuleCall_1_0_0_1; }

		//simpleType=ASN1_TYPE
		public Assignment getSimpleTypeAssignment_1_1() { return cSimpleTypeAssignment_1_1; }

		//ASN1_TYPE
		public RuleCall getSimpleTypeASN1_TYPEParserRuleCall_1_1_0() { return cSimpleTypeASN1_TYPEParserRuleCall_1_1_0; }
	}

	public class ASN1_TYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cASN1_SIMPLEParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cASN1_CHOICEParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// Simple and structured types. 
		//ASN1_TYPE:
		//	ASN1_SIMPLE | ASN1_CHOICE;
		public ParserRule getRule() { return rule; }

		//ASN1_SIMPLE | ASN1_CHOICE
		public Alternatives getAlternatives() { return cAlternatives; }

		//ASN1_SIMPLE
		public RuleCall getASN1_SIMPLEParserRuleCall_0() { return cASN1_SIMPLEParserRuleCall_0; }

		//ASN1_CHOICE
		public RuleCall getASN1_CHOICEParserRuleCall_1() { return cASN1_CHOICEParserRuleCall_1; }
	}

	public class ASN1_SIMPLEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_SIMPLE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cASN1_SIMPLEAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final RuleCall cIA5STRINGTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final RuleCall cASN1_OCTET_STRINGParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cASN1_INTEGERParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cConstraintAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cConstraintASN1_SUBTYPEParserRuleCall_2_1_1_0 = (RuleCall)cConstraintAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		
		//// -- the "base types" defined here are:
		//// --   3 built-in ASN.1 types: INTEGER, OCTET STRING, OBJECT IDENTIFIER
		//ASN1_SIMPLE:
		//	{ASN1_SIMPLE} IA5STRING | ASN1_OCTET_STRING | ASN1_INTEGER ("(" constraint=ASN1_SUBTYPE ")")?;
		public ParserRule getRule() { return rule; }

		//{ASN1_SIMPLE} IA5STRING | ASN1_OCTET_STRING | ASN1_INTEGER ("(" constraint=ASN1_SUBTYPE ")")?
		public Alternatives getAlternatives() { return cAlternatives; }

		//{ASN1_SIMPLE} IA5STRING
		public Group getGroup_0() { return cGroup_0; }

		//{ASN1_SIMPLE}
		public Action getASN1_SIMPLEAction_0_0() { return cASN1_SIMPLEAction_0_0; }

		//IA5STRING
		public RuleCall getIA5STRINGTerminalRuleCall_0_1() { return cIA5STRINGTerminalRuleCall_0_1; }

		//ASN1_OCTET_STRING
		public RuleCall getASN1_OCTET_STRINGParserRuleCall_1() { return cASN1_OCTET_STRINGParserRuleCall_1; }

		//ASN1_INTEGER ("(" constraint=ASN1_SUBTYPE ")")?
		public Group getGroup_2() { return cGroup_2; }

		//ASN1_INTEGER
		public RuleCall getASN1_INTEGERParserRuleCall_2_0() { return cASN1_INTEGERParserRuleCall_2_0; }

		//("(" constraint=ASN1_SUBTYPE ")")?
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2_1_0() { return cLeftParenthesisKeyword_2_1_0; }

		//constraint=ASN1_SUBTYPE
		public Assignment getConstraintAssignment_2_1_1() { return cConstraintAssignment_2_1_1; }

		//ASN1_SUBTYPE
		public RuleCall getConstraintASN1_SUBTYPEParserRuleCall_2_1_1_0() { return cConstraintASN1_SUBTYPEParserRuleCall_2_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_2_1_2() { return cRightParenthesisKeyword_2_1_2; }
	}

	public class ASN1_OCTET_STRINGElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_OCTET_STRING");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cASN1_OCTET_STRINGAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOCTETSTRINGKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cTODODefintionsKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// TODO1 Requries further definition. 	
		//ASN1_OCTET_STRING returns ASN1_SIMPLE:
		//	{ASN1_OCTET_STRING} "OCTET STRING" "TODO defintions.";
		public ParserRule getRule() { return rule; }

		//{ASN1_OCTET_STRING} "OCTET STRING" "TODO defintions."
		public Group getGroup() { return cGroup; }

		//{ASN1_OCTET_STRING}
		public Action getASN1_OCTET_STRINGAction_0() { return cASN1_OCTET_STRINGAction_0; }

		//"OCTET STRING"
		public Keyword getOCTETSTRINGKeyword_1() { return cOCTETSTRINGKeyword_1; }

		//"TODO defintions."
		public Keyword getTODODefintionsKeyword_2() { return cTODODefintionsKeyword_2; }
	}

	public class ASN1_INTEGERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_INTEGER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cINTEGERKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValuePairsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValuePairsASN1_VALUEPAIRParserRuleCall_2_0 = (RuleCall)cValuePairsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ASN1_INTEGER returns ASN1_SIMPLE:
		//	"INTEGER" "{" valuePairs+=ASN1_VALUEPAIR+ "}";
		public ParserRule getRule() { return rule; }

		//"INTEGER" "{" valuePairs+=ASN1_VALUEPAIR+ "}"
		public Group getGroup() { return cGroup; }

		//"INTEGER"
		public Keyword getINTEGERKeyword_0() { return cINTEGERKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//valuePairs+=ASN1_VALUEPAIR+
		public Assignment getValuePairsAssignment_2() { return cValuePairsAssignment_2; }

		//ASN1_VALUEPAIR
		public RuleCall getValuePairsASN1_VALUEPAIRParserRuleCall_2_0() { return cValuePairsASN1_VALUEPAIRParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class ASN1_VALUEPAIRElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_VALUEPAIR");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// TODO1 further specify id, as enum entry in the vp
		//ASN1_VALUEPAIR:
		//	ID? "(" INT ")";
		public ParserRule getRule() { return rule; }

		//ID? "(" INT ")"
		public Group getGroup() { return cGroup; }

		//ID?
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ASN1_CHOICEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_CHOICE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCHOICEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cChoicesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cChoicesASN1_CHOICE_ENTRYParserRuleCall_2_0 = (RuleCall)cChoicesAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCommaKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cChoicesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cChoicesASN1_CHOICE_ENTRYParserRuleCall_3_1_0 = (RuleCall)cChoicesAssignment_3_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// http://www.obj-sys.com/asn1tutorial/node11.html
		//ASN1_CHOICE:
		//	"CHOICE" "{" choices+=ASN1_CHOICE_ENTRY ("," choices+=ASN1_CHOICE_ENTRY)* "}";
		public ParserRule getRule() { return rule; }

		//"CHOICE" "{" choices+=ASN1_CHOICE_ENTRY ("," choices+=ASN1_CHOICE_ENTRY)* "}"
		public Group getGroup() { return cGroup; }

		//"CHOICE"
		public Keyword getCHOICEKeyword_0() { return cCHOICEKeyword_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }

		//choices+=ASN1_CHOICE_ENTRY
		public Assignment getChoicesAssignment_2() { return cChoicesAssignment_2; }

		//ASN1_CHOICE_ENTRY
		public RuleCall getChoicesASN1_CHOICE_ENTRYParserRuleCall_2_0() { return cChoicesASN1_CHOICE_ENTRYParserRuleCall_2_0; }

		//("," choices+=ASN1_CHOICE_ENTRY)*
		public Group getGroup_3() { return cGroup_3; }

		//","
		public Keyword getCommaKeyword_3_0() { return cCommaKeyword_3_0; }

		//choices+=ASN1_CHOICE_ENTRY
		public Assignment getChoicesAssignment_3_1() { return cChoicesAssignment_3_1; }

		//ASN1_CHOICE_ENTRY
		public RuleCall getChoicesASN1_CHOICE_ENTRYParserRuleCall_3_1_0() { return cChoicesASN1_CHOICE_ENTRYParserRuleCall_3_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}

	public class ASN1_CHOICE_ENTRYElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_CHOICE_ENTRY");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdASN1_IDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Assignment cValueTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cValueTypeValueTypeCrossReference_1_0 = (CrossReference)cValueTypeAssignment_1.eContents().get(0);
		private final RuleCall cValueTypeValueTypeIDTerminalRuleCall_1_0_1 = (RuleCall)cValueTypeValueTypeCrossReference_1_0.eContents().get(1);
		
		//// TODO1 The reference to a ValueType is indented by 4 WS on the next line. 
		////  
		//ASN1_CHOICE_ENTRY:
		//	id=ASN1_ID valueType=[ValueType];
		public ParserRule getRule() { return rule; }

		//id=ASN1_ID valueType=[ValueType]
		public Group getGroup() { return cGroup; }

		//id=ASN1_ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//ASN1_ID
		public RuleCall getIdASN1_IDTerminalRuleCall_0_0() { return cIdASN1_IDTerminalRuleCall_0_0; }

		//valueType=[ValueType]
		public Assignment getValueTypeAssignment_1() { return cValueTypeAssignment_1; }

		//[ValueType]
		public CrossReference getValueTypeValueTypeCrossReference_1_0() { return cValueTypeValueTypeCrossReference_1_0; }

		//ID
		public RuleCall getValueTypeValueTypeIDTerminalRuleCall_1_0_1() { return cValueTypeValueTypeIDTerminalRuleCall_1_0_1; }
	}

	public class ASN1_SUBTYPEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_SUBTYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cSIZEKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Assignment cRangeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cRangeASN1_RANGEParserRuleCall_0_1_0 = (RuleCall)cRangeAssignment_0_1.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//// Either a Range or a single value on size.
		//ASN1_SUBTYPE:
		//	"SIZE" range=ASN1_RANGE | value=INT;
		public ParserRule getRule() { return rule; }

		//"SIZE" range=ASN1_RANGE | value=INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//"SIZE" range=ASN1_RANGE
		public Group getGroup_0() { return cGroup_0; }

		//"SIZE"
		public Keyword getSIZEKeyword_0_0() { return cSIZEKeyword_0_0; }

		//range=ASN1_RANGE
		public Assignment getRangeAssignment_0_1() { return cRangeAssignment_0_1; }

		//ASN1_RANGE
		public RuleCall getRangeASN1_RANGEParserRuleCall_0_1_0() { return cRangeASN1_RANGEParserRuleCall_0_1_0; }

		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}

	public class ASN1_RANGEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_RANGE");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cASN1_RANGEAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cStartAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cStartINTTerminalRuleCall_2_0_0 = (RuleCall)cStartAssignment_2_0.eContents().get(0);
		private final Keyword cFullStopFullStopKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cEndAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cEndINTTerminalRuleCall_2_2_0 = (RuleCall)cEndAssignment_2_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ASN1_RANGE:
		//	{ASN1_RANGE} "(" (start=INT ".." end=INT) ")";
		public ParserRule getRule() { return rule; }

		//{ASN1_RANGE} "(" (start=INT ".." end=INT) ")"
		public Group getGroup() { return cGroup; }

		//{ASN1_RANGE}
		public Action getASN1_RANGEAction_0() { return cASN1_RANGEAction_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//start=INT ".." end=INT
		public Group getGroup_2() { return cGroup_2; }

		//start=INT
		public Assignment getStartAssignment_2_0() { return cStartAssignment_2_0; }

		//INT
		public RuleCall getStartINTTerminalRuleCall_2_0_0() { return cStartINTTerminalRuleCall_2_0_0; }

		//".."
		public Keyword getFullStopFullStopKeyword_2_1() { return cFullStopFullStopKeyword_2_1; }

		//end=INT
		public Assignment getEndAssignment_2_2() { return cEndAssignment_2_2; }

		//INT
		public RuleCall getEndINTTerminalRuleCall_2_2_0() { return cEndINTTerminalRuleCall_2_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class ObjectIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObjectIdentifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDescriptorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDescriptorASN1_IDTerminalRuleCall_0_0 = (RuleCall)cDescriptorAssignment_0.eContents().get(0);
		private final Keyword cOBJECTIDENTIFIERKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cColonColonEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cOidValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cOidValueObjectIdentifierValueParserRuleCall_4_0 = (RuleCall)cOidValueAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// ASN.1 
		//// Type OBJECT IDENTIFIER names information objects (for example, abstract syntaxes or ASN.1 modules). 
		//// The type notation requires the keywords OBJECT IDENTIFIER. 
		//// The named information object is a node on an object identifier tree that is managed at the international level. 
		//// ISO, CCITT, or any other organization is allowed a subtree which the organization defines. 
		//// TODO1 is the id, same as the ASN1_ID? 
		//ObjectIdentifier:
		//	descriptor=ASN1_ID "OBJECT IDENTIFIER" "::=" "{" oidValue=ObjectIdentifierValue "}";
		public ParserRule getRule() { return rule; }

		//descriptor=ASN1_ID "OBJECT IDENTIFIER" "::=" "{" oidValue=ObjectIdentifierValue "}"
		public Group getGroup() { return cGroup; }

		//descriptor=ASN1_ID
		public Assignment getDescriptorAssignment_0() { return cDescriptorAssignment_0; }

		//ASN1_ID
		public RuleCall getDescriptorASN1_IDTerminalRuleCall_0_0() { return cDescriptorASN1_IDTerminalRuleCall_0_0; }

		//"OBJECT IDENTIFIER"
		public Keyword getOBJECTIDENTIFIERKeyword_1() { return cOBJECTIDENTIFIERKeyword_1; }

		//"::="
		public Keyword getColonColonEqualsSignKeyword_2() { return cColonColonEqualsSignKeyword_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//oidValue=ObjectIdentifierValue
		public Assignment getOidValueAssignment_4() { return cOidValueAssignment_4; }

		//ObjectIdentifierValue
		public RuleCall getOidValueObjectIdentifierValueParserRuleCall_4_0() { return cOidValueObjectIdentifierValueParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class ObjectIdentifierValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ObjectIdentifierValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDescriptorReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cDescriptorReferenceObjectIdentifierCrossReference_0_0 = (CrossReference)cDescriptorReferenceAssignment_0.eContents().get(0);
		private final RuleCall cDescriptorReferenceObjectIdentifierASN1_IDTerminalRuleCall_0_0_1 = (RuleCall)cDescriptorReferenceObjectIdentifierCrossReference_0_0.eContents().get(1);
		private final Assignment cSubIdsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubIdsINTTerminalRuleCall_1_0 = (RuleCall)cSubIdsAssignment_1.eContents().get(0);
		private final Assignment cSubIdsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSubIdsINTTerminalRuleCall_2_0 = (RuleCall)cSubIdsAssignment_2.eContents().get(0);
		
		//// Secion 3.5 
		////For the SMIv2, each number in the list is referred to as a
		////   sub-identifier, there are at most 128 sub-identifiers in a value, and
		////   each sub-identifier has a maximum value of 2^32-1 (4294967295
		////   decimal).
		////
		//// Notes: The feature 'subID' as a list of sub-identifiers which needs to be interpreted by a Value converter.
		//// The reference to the descriptor is optional, as the sub ID's could provide an absolute sub ID path.
		//// The sub ID path is a list of references, to ObjectIdentifier's position. 
		//// An OBJECT IDENTIFIER value is an ordered list of non-negative
		//// numbers.  For the SMIv2, each number in the list is referred to as a
		//// sub-identifier, there are at most 128 sub-identifiers in a value, and
		//// each sub-identifier has a maximum value of 2^32-1 (4294967295
		//// decimal).
		//// TODO1 Support for construct: { name name2(0) 3} ????
		//// TODO2: Support for well-known types -> Requires a static construction of well-known types in the ScopeProvider 
		//// for the reference to a 'Well-Known' ObjectIdentifier. 
		//ObjectIdentifierValue:
		//	descriptorReference=[ObjectIdentifier|ASN1_ID]? subIds+=INT subIds+=INT*;
		public ParserRule getRule() { return rule; }

		//descriptorReference=[ObjectIdentifier|ASN1_ID]? subIds+=INT subIds+=INT*
		public Group getGroup() { return cGroup; }

		//descriptorReference=[ObjectIdentifier|ASN1_ID]?
		public Assignment getDescriptorReferenceAssignment_0() { return cDescriptorReferenceAssignment_0; }

		//[ObjectIdentifier|ASN1_ID]
		public CrossReference getDescriptorReferenceObjectIdentifierCrossReference_0_0() { return cDescriptorReferenceObjectIdentifierCrossReference_0_0; }

		//ASN1_ID
		public RuleCall getDescriptorReferenceObjectIdentifierASN1_IDTerminalRuleCall_0_0_1() { return cDescriptorReferenceObjectIdentifierASN1_IDTerminalRuleCall_0_0_1; }

		//subIds+=INT
		public Assignment getSubIdsAssignment_1() { return cSubIdsAssignment_1; }

		//INT
		public RuleCall getSubIdsINTTerminalRuleCall_1_0() { return cSubIdsINTTerminalRuleCall_1_0; }

		//subIds+=INT*
		public Assignment getSubIdsAssignment_2() { return cSubIdsAssignment_2; }

		//INT
		public RuleCall getSubIdsINTTerminalRuleCall_2_0() { return cSubIdsINTTerminalRuleCall_2_0; }
	}
	
	
	public class MACRO_VALUE_TYPEElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "MACRO_VALUE_TYPE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cVALUEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cVALUEVALUEKeyword_0_0 = (Keyword)cVALUEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUpdateEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUpdateUpdateKeyword_1_0 = (Keyword)cUpdateEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MACRO_VALUE_TYPE:
		//	VALUE | Update;
		public EnumRule getRule() { return rule; }

		//VALUE | Update
		public Alternatives getAlternatives() { return cAlternatives; }

		//VALUE
		public EnumLiteralDeclaration getVALUEEnumLiteralDeclaration_0() { return cVALUEEnumLiteralDeclaration_0; }

		//"VALUE"
		public Keyword getVALUEVALUEKeyword_0_0() { return cVALUEVALUEKeyword_0_0; }

		//Update
		public EnumLiteralDeclaration getUpdateEnumLiteralDeclaration_1() { return cUpdateEnumLiteralDeclaration_1; }

		//"Update"
		public Keyword getUpdateUpdateKeyword_1_0() { return cUpdateUpdateKeyword_1_0; }
	}

	public class WELL_KNOWN_NAMESElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "WELL_KNOWN_NAMES");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCcittEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCcittCcittKeyword_0_0 = (Keyword)cCcittEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cIsoEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cIsoIsoKeyword_1_0 = (Keyword)cIsoEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cJoint_iso_ccittEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cJoint_iso_ccittJointIsoCcittKeyword_2_0 = (Keyword)cJoint_iso_ccittEnumLiteralDeclaration_2.eContents().get(0);
		
		//// Section 3.5 OBJECT IDENTIFIER values
		//// Section 3.5
		////   All OBJECT IDENTIFIER values have at least two sub-identifiers, where
		////   the value of the first sub-identifier is one of the following well-
		////   known names:
		////
		////        Value   Name
		////          0     ccitt
		////          1     iso
		////          2     joint-iso-ccitt 
		//enum WELL_KNOWN_NAMES:
		//	ccitt | iso | joint_iso_ccitt="joint-iso-ccitt";
		public EnumRule getRule() { return rule; }

		//ccitt | iso | joint_iso_ccitt="joint-iso-ccitt"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ccitt
		public EnumLiteralDeclaration getCcittEnumLiteralDeclaration_0() { return cCcittEnumLiteralDeclaration_0; }

		//"ccitt"
		public Keyword getCcittCcittKeyword_0_0() { return cCcittCcittKeyword_0_0; }

		//iso
		public EnumLiteralDeclaration getIsoEnumLiteralDeclaration_1() { return cIsoEnumLiteralDeclaration_1; }

		//"iso"
		public Keyword getIsoIsoKeyword_1_0() { return cIsoIsoKeyword_1_0; }

		//joint_iso_ccitt="joint-iso-ccitt"
		public EnumLiteralDeclaration getJoint_iso_ccittEnumLiteralDeclaration_2() { return cJoint_iso_ccittEnumLiteralDeclaration_2; }

		//"joint-iso-ccitt"
		public Keyword getJoint_iso_ccittJointIsoCcittKeyword_2_0() { return cJoint_iso_ccittJointIsoCcittKeyword_2_0; }
	}
	
	private ModuleElements pModule;
	private AssignmentElements pAssignment;
	private MacroElements pMacro;
	private MacroDescriptorElements pMacroDescriptor;
	private MacroValueElements pMacroValue;
	private MACRO_VALUE_TYPEElements unknownRuleMACRO_VALUE_TYPE;
	private ValueAssignmentElements pValueAssignment;
	private OrElements pOr;
	private ValueTypeElements pValueType;
	private ASN1_TYPEElements pASN1_TYPE;
	private ASN1_SIMPLEElements pASN1_SIMPLE;
	private ASN1_OCTET_STRINGElements pASN1_OCTET_STRING;
	private ASN1_INTEGERElements pASN1_INTEGER;
	private ASN1_VALUEPAIRElements pASN1_VALUEPAIR;
	private ASN1_CHOICEElements pASN1_CHOICE;
	private ASN1_CHOICE_ENTRYElements pASN1_CHOICE_ENTRY;
	private ASN1_SUBTYPEElements pASN1_SUBTYPE;
	private ASN1_RANGEElements pASN1_RANGE;
	private ObjectIdentifierElements pObjectIdentifier;
	private ObjectIdentifierValueElements pObjectIdentifierValue;
	private WELL_KNOWN_NAMESElements unknownRuleWELL_KNOWN_NAMES;
	private TerminalRule tNUMERIC;
	private TerminalRule tALPHA;
	private TerminalRule tALPHA_CAP;
	private TerminalRule tMODULE_ID;
	private TerminalRule tASN1_ID;
	private TerminalRule tIA5STRING;
	private TerminalRule tSL_ASN1_COMMENT;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public SmiGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.netxforge.Smi".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Module:
	//	id=MODULE_ID "DEFINITIONS" "::=" "BEGIN" assignments+=Assignment* "END";
	public ModuleElements getModuleAccess() {
		return (pModule != null) ? pModule : (pModule = new ModuleElements());
	}
	
	public ParserRule getModuleRule() {
		return getModuleAccess().getRule();
	}

	//Assignment:
	//	macros=Macro | types+=ValueAssignment | ObjectIdentifier;
	public AssignmentElements getAssignmentAccess() {
		return (pAssignment != null) ? pAssignment : (pAssignment = new AssignmentElements());
	}
	
	public ParserRule getAssignmentRule() {
		return getAssignmentAccess().getRule();
	}

	//// Section 3.1 
	//// ...Within an information module, each macro invocation appears as:
	////
	////        <descriptor> <macro> <clauses> ::= <value>
	////
	//// where <descriptor> corresponds to an ASN.1 identifier, <macro> names
	//// the macro being invoked, and <clauses> and <value> depend on the
	//// definition of the macro. 
	//Macro:
	//	descriptor=MacroDescriptor "MACRO" "::=" "BEGIN" "TYPE NOTATION" typeNotations+=[ValueAssignment]+ // Reference one or more value assignment. 
	//	"VALUE NOTATION" valueNotation= // Define one Macro value. 
	//	MacroValue // Define 1 or more value assignment. 
	//	innerTypes+=ValueAssignment+ "END";
	public MacroElements getMacroAccess() {
		return (pMacro != null) ? pMacro : (pMacro = new MacroElements());
	}
	
	public ParserRule getMacroRule() {
		return getMacroAccess().getRule();
	}

	//// A Descriptor for the Macro. 
	//MacroDescriptor:
	//	MODULE_ID;
	public MacroDescriptorElements getMacroDescriptorAccess() {
		return (pMacroDescriptor != null) ? pMacroDescriptor : (pMacroDescriptor = new MacroDescriptorElements());
	}
	
	public ParserRule getMacroDescriptorRule() {
		return getMacroDescriptorAccess().getRule();
	}

	////  No description found for this :-( 
	//MacroValue:
	//	{MacroValue} "value(" type=MACRO_VALUE_TYPE? ANY_OTHER ")";
	public MacroValueElements getMacroValueAccess() {
		return (pMacroValue != null) ? pMacroValue : (pMacroValue = new MacroValueElements());
	}
	
	public ParserRule getMacroValueRule() {
		return getMacroValueAccess().getRule();
	}

	//enum MACRO_VALUE_TYPE:
	//	VALUE | Update;
	public MACRO_VALUE_TYPEElements getMACRO_VALUE_TYPEAccess() {
		return (unknownRuleMACRO_VALUE_TYPE != null) ? unknownRuleMACRO_VALUE_TYPE : (unknownRuleMACRO_VALUE_TYPE = new MACRO_VALUE_TYPEElements());
	}
	
	public EnumRule getMACRO_VALUE_TYPERule() {
		return getMACRO_VALUE_TYPEAccess().getRule();
	}

	//// An ASN.1 Value assignment. 
	//ValueAssignment:
	//	typeReference=MODULE_ID "::=" value=Or;
	public ValueAssignmentElements getValueAssignmentAccess() {
		return (pValueAssignment != null) ? pValueAssignment : (pValueAssignment = new ValueAssignmentElements());
	}
	
	public ParserRule getValueAssignmentRule() {
		return getValueAssignmentAccess().getRule();
	}

	//// Allow 'OR' on value types. 
	//Or:
	//	ValueType (({Or.left=current} "|") right=ValueType)*;
	public OrElements getOrAccess() {
		return (pOr != null) ? pOr : (pOr = new OrElements());
	}
	
	public ParserRule getOrRule() {
		return getOrAccess().getRule();
	}

	////Choice:
	//// Notes: The name of the right handside value assignment is optional. 
	//// TODO1 Comma separated, multiple ValueAssignments
	//// Example: 
	//// IndexTypes ::=
	////                  IndexType
	////                | IndexTypes "," IndexType
	//ValueType:
	//	name=IA5STRING? (type=[ValueAssignment] | simpleType=ASN1_TYPE);
	public ValueTypeElements getValueTypeAccess() {
		return (pValueType != null) ? pValueType : (pValueType = new ValueTypeElements());
	}
	
	public ParserRule getValueTypeRule() {
		return getValueTypeAccess().getRule();
	}

	//// Simple and structured types. 
	//ASN1_TYPE:
	//	ASN1_SIMPLE | ASN1_CHOICE;
	public ASN1_TYPEElements getASN1_TYPEAccess() {
		return (pASN1_TYPE != null) ? pASN1_TYPE : (pASN1_TYPE = new ASN1_TYPEElements());
	}
	
	public ParserRule getASN1_TYPERule() {
		return getASN1_TYPEAccess().getRule();
	}

	//// -- the "base types" defined here are:
	//// --   3 built-in ASN.1 types: INTEGER, OCTET STRING, OBJECT IDENTIFIER
	//ASN1_SIMPLE:
	//	{ASN1_SIMPLE} IA5STRING | ASN1_OCTET_STRING | ASN1_INTEGER ("(" constraint=ASN1_SUBTYPE ")")?;
	public ASN1_SIMPLEElements getASN1_SIMPLEAccess() {
		return (pASN1_SIMPLE != null) ? pASN1_SIMPLE : (pASN1_SIMPLE = new ASN1_SIMPLEElements());
	}
	
	public ParserRule getASN1_SIMPLERule() {
		return getASN1_SIMPLEAccess().getRule();
	}

	//// TODO1 Requries further definition. 	
	//ASN1_OCTET_STRING returns ASN1_SIMPLE:
	//	{ASN1_OCTET_STRING} "OCTET STRING" "TODO defintions.";
	public ASN1_OCTET_STRINGElements getASN1_OCTET_STRINGAccess() {
		return (pASN1_OCTET_STRING != null) ? pASN1_OCTET_STRING : (pASN1_OCTET_STRING = new ASN1_OCTET_STRINGElements());
	}
	
	public ParserRule getASN1_OCTET_STRINGRule() {
		return getASN1_OCTET_STRINGAccess().getRule();
	}

	//ASN1_INTEGER returns ASN1_SIMPLE:
	//	"INTEGER" "{" valuePairs+=ASN1_VALUEPAIR+ "}";
	public ASN1_INTEGERElements getASN1_INTEGERAccess() {
		return (pASN1_INTEGER != null) ? pASN1_INTEGER : (pASN1_INTEGER = new ASN1_INTEGERElements());
	}
	
	public ParserRule getASN1_INTEGERRule() {
		return getASN1_INTEGERAccess().getRule();
	}

	//// TODO1 further specify id, as enum entry in the vp
	//ASN1_VALUEPAIR:
	//	ID? "(" INT ")";
	public ASN1_VALUEPAIRElements getASN1_VALUEPAIRAccess() {
		return (pASN1_VALUEPAIR != null) ? pASN1_VALUEPAIR : (pASN1_VALUEPAIR = new ASN1_VALUEPAIRElements());
	}
	
	public ParserRule getASN1_VALUEPAIRRule() {
		return getASN1_VALUEPAIRAccess().getRule();
	}

	//// http://www.obj-sys.com/asn1tutorial/node11.html
	//ASN1_CHOICE:
	//	"CHOICE" "{" choices+=ASN1_CHOICE_ENTRY ("," choices+=ASN1_CHOICE_ENTRY)* "}";
	public ASN1_CHOICEElements getASN1_CHOICEAccess() {
		return (pASN1_CHOICE != null) ? pASN1_CHOICE : (pASN1_CHOICE = new ASN1_CHOICEElements());
	}
	
	public ParserRule getASN1_CHOICERule() {
		return getASN1_CHOICEAccess().getRule();
	}

	//// TODO1 The reference to a ValueType is indented by 4 WS on the next line. 
	////  
	//ASN1_CHOICE_ENTRY:
	//	id=ASN1_ID valueType=[ValueType];
	public ASN1_CHOICE_ENTRYElements getASN1_CHOICE_ENTRYAccess() {
		return (pASN1_CHOICE_ENTRY != null) ? pASN1_CHOICE_ENTRY : (pASN1_CHOICE_ENTRY = new ASN1_CHOICE_ENTRYElements());
	}
	
	public ParserRule getASN1_CHOICE_ENTRYRule() {
		return getASN1_CHOICE_ENTRYAccess().getRule();
	}

	//// Either a Range or a single value on size.
	//ASN1_SUBTYPE:
	//	"SIZE" range=ASN1_RANGE | value=INT;
	public ASN1_SUBTYPEElements getASN1_SUBTYPEAccess() {
		return (pASN1_SUBTYPE != null) ? pASN1_SUBTYPE : (pASN1_SUBTYPE = new ASN1_SUBTYPEElements());
	}
	
	public ParserRule getASN1_SUBTYPERule() {
		return getASN1_SUBTYPEAccess().getRule();
	}

	//ASN1_RANGE:
	//	{ASN1_RANGE} "(" (start=INT ".." end=INT) ")";
	public ASN1_RANGEElements getASN1_RANGEAccess() {
		return (pASN1_RANGE != null) ? pASN1_RANGE : (pASN1_RANGE = new ASN1_RANGEElements());
	}
	
	public ParserRule getASN1_RANGERule() {
		return getASN1_RANGEAccess().getRule();
	}

	//// ASN.1 
	//// Type OBJECT IDENTIFIER names information objects (for example, abstract syntaxes or ASN.1 modules). 
	//// The type notation requires the keywords OBJECT IDENTIFIER. 
	//// The named information object is a node on an object identifier tree that is managed at the international level. 
	//// ISO, CCITT, or any other organization is allowed a subtree which the organization defines. 
	//// TODO1 is the id, same as the ASN1_ID? 
	//ObjectIdentifier:
	//	descriptor=ASN1_ID "OBJECT IDENTIFIER" "::=" "{" oidValue=ObjectIdentifierValue "}";
	public ObjectIdentifierElements getObjectIdentifierAccess() {
		return (pObjectIdentifier != null) ? pObjectIdentifier : (pObjectIdentifier = new ObjectIdentifierElements());
	}
	
	public ParserRule getObjectIdentifierRule() {
		return getObjectIdentifierAccess().getRule();
	}

	//// Secion 3.5 
	////For the SMIv2, each number in the list is referred to as a
	////   sub-identifier, there are at most 128 sub-identifiers in a value, and
	////   each sub-identifier has a maximum value of 2^32-1 (4294967295
	////   decimal).
	////
	//// Notes: The feature 'subID' as a list of sub-identifiers which needs to be interpreted by a Value converter.
	//// The reference to the descriptor is optional, as the sub ID's could provide an absolute sub ID path.
	//// The sub ID path is a list of references, to ObjectIdentifier's position. 
	//// An OBJECT IDENTIFIER value is an ordered list of non-negative
	//// numbers.  For the SMIv2, each number in the list is referred to as a
	//// sub-identifier, there are at most 128 sub-identifiers in a value, and
	//// each sub-identifier has a maximum value of 2^32-1 (4294967295
	//// decimal).
	//// TODO1 Support for construct: { name name2(0) 3} ????
	//// TODO2: Support for well-known types -> Requires a static construction of well-known types in the ScopeProvider 
	//// for the reference to a 'Well-Known' ObjectIdentifier. 
	//ObjectIdentifierValue:
	//	descriptorReference=[ObjectIdentifier|ASN1_ID]? subIds+=INT subIds+=INT*;
	public ObjectIdentifierValueElements getObjectIdentifierValueAccess() {
		return (pObjectIdentifierValue != null) ? pObjectIdentifierValue : (pObjectIdentifierValue = new ObjectIdentifierValueElements());
	}
	
	public ParserRule getObjectIdentifierValueRule() {
		return getObjectIdentifierValueAccess().getRule();
	}

	//// Section 3.5 OBJECT IDENTIFIER values
	//// Section 3.5
	////   All OBJECT IDENTIFIER values have at least two sub-identifiers, where
	////   the value of the first sub-identifier is one of the following well-
	////   known names:
	////
	////        Value   Name
	////          0     ccitt
	////          1     iso
	////          2     joint-iso-ccitt 
	//enum WELL_KNOWN_NAMES:
	//	ccitt | iso | joint_iso_ccitt="joint-iso-ccitt";
	public WELL_KNOWN_NAMESElements getWELL_KNOWN_NAMESAccess() {
		return (unknownRuleWELL_KNOWN_NAMES != null) ? unknownRuleWELL_KNOWN_NAMES : (unknownRuleWELL_KNOWN_NAMES = new WELL_KNOWN_NAMESElements());
	}
	
	public EnumRule getWELL_KNOWN_NAMESRule() {
		return getWELL_KNOWN_NAMESAccess().getRule();
	}

	//// Fragments.
	//terminal fragment NUMERIC:
	//	"0".."9";
	public TerminalRule getNUMERICRule() {
		return (tNUMERIC != null) ? tNUMERIC : (tNUMERIC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMERIC"));
	} 

	//terminal fragment ALPHA:
	//	"a".."z";
	public TerminalRule getALPHARule() {
		return (tALPHA != null) ? tALPHA : (tALPHA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ALPHA"));
	} 

	//terminal fragment ALPHA_CAP:
	//	"A".."Z";
	public TerminalRule getALPHA_CAPRule() {
		return (tALPHA_CAP != null) ? tALPHA_CAP : (tALPHA_CAP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ALPHA_CAP"));
	} 

	//// Section 3 
	//// ...an ASN.1 module name begins with an upper-case letter
	//// and continues with zero or more letters, digits, or hyphens, except
	//// that a hyphen can not be the last character, nor can there be two
	//// consecutive hyphens.
	//// TODO1 !('--') doesn't work, need to break it down. 
	//// TODO2 ending on non-Hyphen. 
	//terminal MODULE_ID:
	//	ALPHA_CAP (ALPHA | ALPHA_CAP | "-" | NUMERIC)* (ALPHA_CAP | ALPHA | NUMERIC);
	public TerminalRule getMODULE_IDRule() {
		return (tMODULE_ID != null) ? tMODULE_ID : (tMODULE_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "MODULE_ID"));
	} 

	//// Section 3.1 
	//// ...an ASN.1 identifier consists
	//// of one or more letters or digits, and its initial character must be a
	//// lower-case letter.  Note that hyphens are not allowed by this
	//// specification (except for use by information modules converted from
	//// SMIv1 which did allow hyphens).
	////   For all descriptors appearing in an information module, the
	////   descriptor shall be unique and mnemonic, and shall not exceed 64
	////   characters in length.  (However, descriptors longer than 32
	////   characters are not recommended.)  This promotes a common language for
	////   humans to use when discussing the information module and also
	////   facilitates simple table mappings for user-interfaces.
	////
	////   The set of descriptors defined in all "standard" information modules
	////   shall be unique.
	////
	////   Finally, by convention, if the descriptor refers to an object with a
	////   SYNTAX clause value of either Counter32 or Counter64, then the
	////   descriptor used for the object should denote plurality.
	//// CB Except statement??? 
	//// TODO1 Limit the size of the ID. 
	//// TODO2 SYNTAX Clause in ? Identifier? 
	//terminal ASN1_ID:
	//	ALPHA (ALPHA | ALPHA_CAP | "-" | NUMERIC)*;
	public TerminalRule getASN1_IDRule() {
		return (tASN1_ID != null) ? tASN1_ID : (tASN1_ID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ASN1_ID"));
	} 

	//// Section 3.1.1 
	//// character string is preceded and followed by the quote character
	////   ("), and consists of an arbitrary number (possibly zero) of:
	////
	////      - any 7-bit displayable ASCII characters except quote ("),
	////      - tab characters,
	////      - spaces, and
	////      - line terminator characters (\n or \r\n).
	////
	////   The value of a character string is interpreted as ASCII.
	//// TODO, \", \' not needed? what about Hex values. 
	//terminal IA5STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"";
	public TerminalRule getIA5STRINGRule() {
		return (tIA5STRING != null) ? tIA5STRING : (tIA5STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "IA5STRING"));
	} 

	//// Section 3.4 
	//// ... ASN.1 comments commence with a pair of adjacent hyphens and end with
	//// the next pair of adjacent hyphens or at the end of the line,
	//// whichever occurs first.  Comments ended by a pair of hyphens have the
	//// effect of a single space character.
	//// TODO1 Comments ended by a pair of hyphens have the effect of a single space character.
	//terminal SL_ASN1_COMMENT:
	//	"--" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_ASN1_COMMENTRule() {
		return (tSL_ASN1_COMMENT != null) ? tSL_ASN1_COMMENT : (tSL_ASN1_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "SL_ASN1_COMMENT"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
