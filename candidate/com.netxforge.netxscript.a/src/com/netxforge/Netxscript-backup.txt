/*******************************************************************************
NetXScript interpreter. 
Supports: 

Arithmetics
Functions
Variables
Keyword substitution, and referenced model/feature lookup.

*******************************************************************************/
grammar com.netxforge.Netxscript with org.eclipse.xtext.common.Terminals

generate netxscript "http://www.netxforge.com/Netxscript"

// Declare an alias to access ecore types. 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
// Note we can't use the nsURI, as it won't be found in development time. On the other hand the resource
// uri won't be found in runtime??? 
import "platform:/resource/com.netxforge.model.a/model/library.ecore" as library



Mod:
	'mod' name=ID
	(imports+=Import)*
	(functions+=Function)+;

Context:
	'context' context=[ecore::EObject]
;

Import:
	'import' importURI=STRING;

	//ImportName:
//	ID ('.' '*')?;

// TODO, we can't have mandatory brackets, as this would conflict with our PrimaryExpression. 
Function:
	'def' name=ID '(' (args+=Argument (',' args+=Argument)*)? ')'
	block=Block;

Argument:
	name=ID;

AbstractVarOrArgument:
	VariableStatement | Argument;

AbstractFunction:
	Function;

Block:
	'{' {Block} statements+=Statement* '}';

Statement:
	{BlankStatement} ';' | VariableStatement ';' | Block;

VariableStatement returns Statement:
	expression=Expression | {Variable} name=ID ('=') expression=Expression;

	// Expression, all operators extend this class. 
Expression:
	Logical;

	// Logical	
Logical returns Expression:
	Equality (({And.left=current} '&&' | {Or.left=current} '||') right=Equality)*;

	// Equal, Non-Equal 
Equality returns Expression:
	Comparison (({Equal.left=current} '==' | {Unequal.left=current} '!=') right=Comparison)*;

	// Lesser, Greater. 
Comparison returns Expression:
	Addition (({Lesser.left=current} '<'
	| {LesserEqual.left=current} '<='
	| {Greater.left=current} '>'
	| {GreaterEqual.left=current} '>=') right=Addition)*;

Addition returns Expression:
	Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*;

Multiplication returns Expression:
	Unary (({Multi.left=current} '*'
	| {Div.left=current} '/'
	| {Modulo.left=current} '%') right=Unary)*;

	// Unaries are return type specific. The type on the right should be checked.  
Unary returns Expression:
	PrimaryExpression |
	({Negation} op='!' | {UnaryPlusMinus} op=UnaryOperator) right=Unary;

UnaryOperator:
	'-' |
	'+';


// TODO, a functionCall is not necessarly an abstract definition in this grammar, but could 
// be an internal function call. For this we could mixin, a grammar which contains
// all internal calls.

// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
PrimaryExpression returns Expression:
	Literal |
	Reference |
	FunctionCall |
	VarOrArgumentCall |
	ParenthesizedExpression
	;

Literal returns Expression:
	{NumberLiteral} value=NUMBER |
	{BooleanLiteral} condition?=BOOLEAN
;

ParenthesizedExpression returns Expression:
	'(' Expression ')'
;

FunctionCall returns Expression:
	{FunctionCall} func=[AbstractFunction] '(' (args+=Expression (',' args+=Expression)*)? ')';

VarOrArgumentCall returns Expression:
	{VarOrArgumentCall} call=[AbstractVarOrArgument];

ReturnExpression returns Expression:
	{ReturnExpression} 'return' (=>expression=Expression)?
;

Reference returns Expression:
	ContextRef ('.' nativeFunction=NativeFunction)?
;

/**
 * Contextual reference will be restricted by a container in the scope provider
 * depending on the object representation of 'this', until implemented, all possible 
 * references will be visible.  
 */
ContextRef returns Reference:
	'this' NodeRef
;

/**
 * Exteral Node references, these can be nested and finish with a resource reference.
 */
NodeRef returns Reference:
	( nodes+=PrimaryNodeRef)+ ('->' ref=(ResourceRef | LinkRef))?;

PrimaryNodeRef returns Reference:
	{NodeRef} '->' node=[library::Node];

ResourceRef returns Reference:
	{ResourceRef}'RES' resource=[library::Resource]
;

LinkRef returns Reference:
	{LinkRef}'LINK' link=[library::Link]
;




terminal NativeFunction returns ecore::EString:
	('count' | 'sum' | 'erlangB' | 'trend' | 'metricRange')
;

terminal NUMBER returns ecore::EBigDecimal:
	('0'..'9')* ('.' ('0'..'9')+)?;

terminal BOOLEAN returns ecore::EBoolean:
	'true' | 'false';

terminal INT returns ecore::EInt:
	'this one has been deactivated';
	
