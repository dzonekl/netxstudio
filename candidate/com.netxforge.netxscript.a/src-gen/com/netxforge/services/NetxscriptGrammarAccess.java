/*
* generated by Xtext
*/

package com.netxforge.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class NetxscriptGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ModElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Mod");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cImportsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cImportsImportParserRuleCall_2_0 = (RuleCall)cImportsAssignment_2.eContents().get(0);
		private final Assignment cFunctionsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFunctionsFunctionParserRuleCall_3_0 = (RuleCall)cFunctionsAssignment_3.eContents().get(0);
		
		//Mod:
		//	"mod" name=ID imports+=Import* functions+=Function+;
		public ParserRule getRule() { return rule; }

		//"mod" name=ID imports+=Import* functions+=Function+
		public Group getGroup() { return cGroup; }

		//"mod"
		public Keyword getModKeyword_0() { return cModKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//imports+=Import*
		public Assignment getImportsAssignment_2() { return cImportsAssignment_2; }

		//Import
		public RuleCall getImportsImportParserRuleCall_2_0() { return cImportsImportParserRuleCall_2_0; }

		//functions+=Function+
		public Assignment getFunctionsAssignment_3() { return cFunctionsAssignment_3; }

		//Function
		public RuleCall getFunctionsFunctionParserRuleCall_3_0() { return cFunctionsFunctionParserRuleCall_3_0; }
	}

	public class ImportElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Import");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImportURIAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cImportURISTRINGTerminalRuleCall_1_0 = (RuleCall)cImportURIAssignment_1.eContents().get(0);
		
		//Import:
		//	"import" importURI=STRING;
		public ParserRule getRule() { return rule; }

		//"import" importURI=STRING
		public Group getGroup() { return cGroup; }

		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }

		//importURI=STRING
		public Assignment getImportURIAssignment_1() { return cImportURIAssignment_1; }

		//STRING
		public RuleCall getImportURISTRINGTerminalRuleCall_1_0() { return cImportURISTRINGTerminalRuleCall_1_0; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cArgsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cArgsArgumentParserRuleCall_3_0_0 = (RuleCall)cArgsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cArgsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cArgsArgumentParserRuleCall_3_1_1_0 = (RuleCall)cArgsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBlockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBlockBlockParserRuleCall_5_0 = (RuleCall)cBlockAssignment_5.eContents().get(0);
		
		////ImportName:
		////	ID ('.' '*')?;
		//// TODO, we can't have mandatory brackets, as this would conflict with our PrimaryExpression. 
		//Function:
		//	"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block;
		public ParserRule getRule() { return rule; }

		//"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block
		public Group getGroup() { return cGroup; }

		//"def"
		public Keyword getDefKeyword_0() { return cDefKeyword_0; }

		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(args+=Argument ("," args+=Argument)*)?
		public Group getGroup_3() { return cGroup_3; }

		//args+=Argument
		public Assignment getArgsAssignment_3_0() { return cArgsAssignment_3_0; }

		//Argument
		public RuleCall getArgsArgumentParserRuleCall_3_0_0() { return cArgsArgumentParserRuleCall_3_0_0; }

		//("," args+=Argument)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//args+=Argument
		public Assignment getArgsAssignment_3_1_1() { return cArgsAssignment_3_1_1; }

		//Argument
		public RuleCall getArgsArgumentParserRuleCall_3_1_1_0() { return cArgsArgumentParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }

		//block=Block
		public Assignment getBlockAssignment_5() { return cBlockAssignment_5; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_5_0() { return cBlockBlockParserRuleCall_5_0; }
	}

	public class ArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Argument");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Argument:
		//	name=ID;
		public ParserRule getRule() { return rule; }

		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}

	public class AbstractVarOrArgumentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractVarOrArgument");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cVariableStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArgumentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractVarOrArgument:
		//	VariableStatement | Argument;
		public ParserRule getRule() { return rule; }

		//VariableStatement | Argument
		public Alternatives getAlternatives() { return cAlternatives; }

		//VariableStatement
		public RuleCall getVariableStatementParserRuleCall_0() { return cVariableStatementParserRuleCall_0; }

		//Argument
		public RuleCall getArgumentParserRuleCall_1() { return cArgumentParserRuleCall_1; }
	}

	public class AbstractFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AbstractFunction");
		private final RuleCall cFunctionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//AbstractFunction:
		//	Function;
		public ParserRule getRule() { return rule; }

		//Function
		public RuleCall getFunctionParserRuleCall() { return cFunctionParserRuleCall; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cBlockAction_1 = (Action)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementsStatementParserRuleCall_2_0 = (RuleCall)cStatementsAssignment_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block:
		//	"{" {Block} statements+=Statement* "}";
		public ParserRule getRule() { return rule; }

		//"{" {Block} statements+=Statement* "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//{Block}
		public Action getBlockAction_1() { return cBlockAction_1; }

		//statements+=Statement*
		public Assignment getStatementsAssignment_2() { return cStatementsAssignment_2; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_2_0() { return cStatementsStatementParserRuleCall_2_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cBlankStatementAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cVariableStatementParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final RuleCall cBlockParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Statement:
		//	{BlankStatement} ";" | VariableStatement ";" | Block;
		public ParserRule getRule() { return rule; }

		//{BlankStatement} ";" | VariableStatement ";" | Block
		public Alternatives getAlternatives() { return cAlternatives; }

		//{BlankStatement} ";"
		public Group getGroup_0() { return cGroup_0; }

		//{BlankStatement}
		public Action getBlankStatementAction_0_0() { return cBlankStatementAction_0_0; }

		//";"
		public Keyword getSemicolonKeyword_0_1() { return cSemicolonKeyword_0_1; }

		//VariableStatement ";"
		public Group getGroup_1() { return cGroup_1; }

		//VariableStatement
		public RuleCall getVariableStatementParserRuleCall_1_0() { return cVariableStatementParserRuleCall_1_0; }

		//";"
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//Block
		public RuleCall getBlockParserRuleCall_2() { return cBlockParserRuleCall_2; }
	}

	public class VariableStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VariableStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpressionAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionExpressionParserRuleCall_0_0 = (RuleCall)cExpressionAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cVariableAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNameAssignment_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cExpressionAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_1_3_0 = (RuleCall)cExpressionAssignment_1_3.eContents().get(0);
		
		//VariableStatement returns Statement:
		//	expression=Expression | {Variable} name=ID "=" expression=Expression;
		public ParserRule getRule() { return rule; }

		//expression=Expression | {Variable} name=ID "=" expression=Expression
		public Alternatives getAlternatives() { return cAlternatives; }

		//expression=Expression
		public Assignment getExpressionAssignment_0() { return cExpressionAssignment_0; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_0_0() { return cExpressionExpressionParserRuleCall_0_0; }

		//{Variable} name=ID "=" expression=Expression
		public Group getGroup_1() { return cGroup_1; }

		//{Variable}
		public Action getVariableAction_1_0() { return cVariableAction_1_0; }

		//name=ID
		public Assignment getNameAssignment_1_1() { return cNameAssignment_1_1; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_1_1_0() { return cNameIDTerminalRuleCall_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_2() { return cEqualsSignKeyword_1_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_1_3() { return cExpressionAssignment_1_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_3_0() { return cExpressionExpressionParserRuleCall_1_3_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cLogicalParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Expression, all operators extend this class. 
		//Expression:
		//	Logical;
		public ParserRule getRule() { return rule; }

		//Logical
		public RuleCall getLogicalParserRuleCall() { return cLogicalParserRuleCall; }
	}

	public class LogicalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Logical");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualityParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cAndLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAmpersandAmpersandKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cOrLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightEqualityParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Logical	
		//Logical returns Expression:
		//	Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*;
		public ParserRule getRule() { return rule; }

		//Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*
		public Group getGroup() { return cGroup; }

		//Equality
		public RuleCall getEqualityParserRuleCall_0() { return cEqualityParserRuleCall_0; }

		//(({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current} "&&" | {Or.left=current} "||"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{And.left=current} "&&"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{And.left=current}
		public Action getAndLeftAction_1_0_0_0() { return cAndLeftAction_1_0_0_0; }

		//"&&"
		public Keyword getAmpersandAmpersandKeyword_1_0_0_1() { return cAmpersandAmpersandKeyword_1_0_0_1; }

		//{Or.left=current} "||"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0_1_0() { return cOrLeftAction_1_0_1_0; }

		//"||"
		public Keyword getVerticalLineVerticalLineKeyword_1_0_1_1() { return cVerticalLineVerticalLineKeyword_1_0_1_1; }

		//right=Equality
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Equality
		public RuleCall getRightEqualityParserRuleCall_1_1_0() { return cRightEqualityParserRuleCall_1_1_0; }
	}

	public class EqualityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Equality");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cEqualLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cUnequalLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cExclamationMarkEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightComparisonParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Equal, Non-Equal 
		//Equality returns Expression:
		//	Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*;
		public ParserRule getRule() { return rule; }

		//Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*
		public Group getGroup() { return cGroup; }

		//Comparison
		public RuleCall getComparisonParserRuleCall_0() { return cComparisonParserRuleCall_0; }

		//(({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*
		public Group getGroup_1() { return cGroup_1; }

		//{Equal.left=current} "==" | {Unequal.left=current} "!="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Equal.left=current} "=="
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_0_0_0() { return cEqualLeftAction_1_0_0_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1_0_0_1() { return cEqualsSignEqualsSignKeyword_1_0_0_1; }

		//{Unequal.left=current} "!="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Unequal.left=current}
		public Action getUnequalLeftAction_1_0_1_0() { return cUnequalLeftAction_1_0_1_0; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_1_0_1_1() { return cExclamationMarkEqualsSignKeyword_1_0_1_1; }

		//right=Comparison
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Comparison
		public RuleCall getRightComparisonParserRuleCall_1_1_0() { return cRightComparisonParserRuleCall_1_1_0; }
	}

	public class ComparisonElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Comparison");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAdditionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cLesserLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cLesserEqualLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cGreaterLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Group cGroup_1_0_3 = (Group)cAlternatives_1_0.eContents().get(3);
		private final Action cGreaterEqualLeftAction_1_0_3_0 = (Action)cGroup_1_0_3.eContents().get(0);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_0_3_1 = (Keyword)cGroup_1_0_3.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAdditionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Lesser, Greater. 
		//Comparison returns Expression:
		//	Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
		//	{GreaterEqual.left=current} ">=") right=Addition)*;
		public ParserRule getRule() { return rule; }

		//Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
		//{GreaterEqual.left=current} ">=") right=Addition)*
		public Group getGroup() { return cGroup; }

		//Addition
		public RuleCall getAdditionParserRuleCall_0() { return cAdditionParserRuleCall_0; }

		//(({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" | {GreaterEqual.left=current}
		//">=") right=Addition)*
		public Group getGroup_1() { return cGroup_1; }

		//{Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" | {GreaterEqual.left=current}
		//">="
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Lesser.left=current} "<"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Lesser.left=current}
		public Action getLesserLeftAction_1_0_0_0() { return cLesserLeftAction_1_0_0_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_0_1() { return cLessThanSignKeyword_1_0_0_1; }

		//{LesserEqual.left=current} "<="
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{LesserEqual.left=current}
		public Action getLesserEqualLeftAction_1_0_1_0() { return cLesserEqualLeftAction_1_0_1_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_0_1_1() { return cLessThanSignEqualsSignKeyword_1_0_1_1; }

		//{Greater.left=current} ">"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_0_2_0() { return cGreaterLeftAction_1_0_2_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_2_1() { return cGreaterThanSignKeyword_1_0_2_1; }

		//{GreaterEqual.left=current} ">="
		public Group getGroup_1_0_3() { return cGroup_1_0_3; }

		//{GreaterEqual.left=current}
		public Action getGreaterEqualLeftAction_1_0_3_0() { return cGreaterEqualLeftAction_1_0_3_0; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_0_3_1() { return cGreaterThanSignEqualsSignKeyword_1_0_3_1; }

		//right=Addition
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Addition
		public RuleCall getRightAdditionParserRuleCall_1_1_0() { return cRightAdditionParserRuleCall_1_1_0; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cPlusLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultiplicationParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Addition returns Expression:
		//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//(({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Plus.left=current} "+" | {Minus.left=current} "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Plus.left=current} "+"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Plus.left=current}
		public Action getPlusLeftAction_1_0_0_0() { return cPlusLeftAction_1_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Minus.left=current} "-"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=Multiplication
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Multiplication
		public RuleCall getRightMultiplicationParserRuleCall_1_1_0() { return cRightMultiplicationParserRuleCall_1_1_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultiLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModuloLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//Multiplication returns Expression:
		//	Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*;
		public ParserRule getRule() { return rule; }

		//Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*
		public Group getGroup() { return cGroup; }

		//Unary
		public RuleCall getUnaryParserRuleCall_0() { return cUnaryParserRuleCall_0; }

		//(({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Multi.left=current} "*"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Multi.left=current}
		public Action getMultiLeftAction_1_0_0_0() { return cMultiLeftAction_1_0_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }

		//{Div.left=current} "/"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }

		//{Modulo.left=current} "%"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Modulo.left=current}
		public Action getModuloLeftAction_1_0_2_0() { return cModuloLeftAction_1_0_2_0; }

		//"%"
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=Unary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Unary
		public RuleCall getRightUnaryParserRuleCall_1_1_0() { return cRightUnaryParserRuleCall_1_1_0; }
	}

	public class UnaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Unary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cNegationAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Assignment cOpAssignment_1_0_0_1 = (Assignment)cGroup_1_0_0.eContents().get(1);
		private final Keyword cOpExclamationMarkKeyword_1_0_0_1_0 = (Keyword)cOpAssignment_1_0_0_1.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cUnaryPlusMinusAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Assignment cOpAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cOpUnaryOperatorParserRuleCall_1_0_1_1_0 = (RuleCall)cOpAssignment_1_0_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//// Unaries are return type specific. The type on the right should be checked.  
		//Unary returns Expression:
		//	PrimaryExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary;
		public ParserRule getRule() { return rule; }

		//PrimaryExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimaryExpression
		public RuleCall getPrimaryExpressionParserRuleCall_0() { return cPrimaryExpressionParserRuleCall_0; }

		//({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary
		public Group getGroup_1() { return cGroup_1; }

		//{Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Negation} op="!"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Negation}
		public Action getNegationAction_1_0_0_0() { return cNegationAction_1_0_0_0; }

		//op="!"
		public Assignment getOpAssignment_1_0_0_1() { return cOpAssignment_1_0_0_1; }

		//"!"
		public Keyword getOpExclamationMarkKeyword_1_0_0_1_0() { return cOpExclamationMarkKeyword_1_0_0_1_0; }

		//{UnaryPlusMinus} op=UnaryOperator
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{UnaryPlusMinus}
		public Action getUnaryPlusMinusAction_1_0_1_0() { return cUnaryPlusMinusAction_1_0_1_0; }

		//op=UnaryOperator
		public Assignment getOpAssignment_1_0_1_1() { return cOpAssignment_1_0_1_1; }

		//UnaryOperator
		public RuleCall getOpUnaryOperatorParserRuleCall_1_0_1_1_0() { return cOpUnaryOperatorParserRuleCall_1_0_1_1_0; }

		//right=Unary
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//Unary
		public RuleCall getRightUnaryParserRuleCall_1_1_0() { return cRightUnaryParserRuleCall_1_1_0; }
	}

	public class UnaryOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cPlusSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//UnaryOperator:
		//	"-" | "+";
		public ParserRule getRule() { return rule; }

		//"-" | "+"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"-"
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//"+"
		public Keyword getPlusSignKeyword_1() { return cPlusSignKeyword_1; }
	}

	public class PrimaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNumberLiteralAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cValueAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cValueNUMBERTerminalRuleCall_1_1_0 = (RuleCall)cValueAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cBooleanLiteralAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Assignment cConditionAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cConditionBOOLEANTerminalRuleCall_2_1_0 = (RuleCall)cConditionAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Action cModelReferenceAction_3_0 = (Action)cGroup_3.eContents().get(0);
		private final Assignment cNodeAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cNodeNodeDepthParserRuleCall_3_1_0 = (RuleCall)cNodeAssignment_3_1.eContents().get(0);
		private final RuleCall cFunctionCallParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVarOrArgumentCallParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//// TODO, a functionCall is not necessarly an abstract definition in this grammar, but could 
		//// be an internal function call. For this we could mixin, a grammar which contains
		//// all internal calls.
		//// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
		//PrimaryExpression returns Expression:
		//	"(" Expression ")" | {NumberLiteral} value=NUMBER | {BooleanLiteral} condition?=BOOLEAN | {ModelReference}
		//	node=NodeDepth | FunctionCall | VarOrArgumentCall;
		public ParserRule getRule() { return rule; }

		//"(" Expression ")" | {NumberLiteral} value=NUMBER | {BooleanLiteral} condition?=BOOLEAN | {ModelReference}
		//node=NodeDepth | FunctionCall | VarOrArgumentCall
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//{NumberLiteral} value=NUMBER
		public Group getGroup_1() { return cGroup_1; }

		//{NumberLiteral}
		public Action getNumberLiteralAction_1_0() { return cNumberLiteralAction_1_0; }

		//value=NUMBER
		public Assignment getValueAssignment_1_1() { return cValueAssignment_1_1; }

		//NUMBER
		public RuleCall getValueNUMBERTerminalRuleCall_1_1_0() { return cValueNUMBERTerminalRuleCall_1_1_0; }

		//{BooleanLiteral} condition?=BOOLEAN
		public Group getGroup_2() { return cGroup_2; }

		//{BooleanLiteral}
		public Action getBooleanLiteralAction_2_0() { return cBooleanLiteralAction_2_0; }

		//condition?=BOOLEAN
		public Assignment getConditionAssignment_2_1() { return cConditionAssignment_2_1; }

		//BOOLEAN
		public RuleCall getConditionBOOLEANTerminalRuleCall_2_1_0() { return cConditionBOOLEANTerminalRuleCall_2_1_0; }

		//{ModelReference} node=NodeDepth
		public Group getGroup_3() { return cGroup_3; }

		//{ModelReference}
		public Action getModelReferenceAction_3_0() { return cModelReferenceAction_3_0; }

		//node=NodeDepth
		public Assignment getNodeAssignment_3_1() { return cNodeAssignment_3_1; }

		//NodeDepth
		public RuleCall getNodeNodeDepthParserRuleCall_3_1_0() { return cNodeNodeDepthParserRuleCall_3_1_0; }

		//FunctionCall
		public RuleCall getFunctionCallParserRuleCall_4() { return cFunctionCallParserRuleCall_4; }

		//VarOrArgumentCall
		public RuleCall getVarOrArgumentCallParserRuleCall_5() { return cVarOrArgumentCallParserRuleCall_5; }
	}

	public class FunctionCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctionCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFuncAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFuncAbstractFunctionCrossReference_1_0 = (CrossReference)cFuncAssignment_1.eContents().get(0);
		private final RuleCall cFuncAbstractFunctionIDTerminalRuleCall_1_0_1 = (RuleCall)cFuncAbstractFunctionCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cArgsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cArgsExpressionParserRuleCall_3_0_0 = (RuleCall)cArgsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cArgsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cArgsExpressionParserRuleCall_3_1_1_0 = (RuleCall)cArgsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//FunctionCall returns Expression:
		//	{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")";
		public ParserRule getRule() { return rule; }

		//{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")"
		public Group getGroup() { return cGroup; }

		//{FunctionCall}
		public Action getFunctionCallAction_0() { return cFunctionCallAction_0; }

		//func=[AbstractFunction]
		public Assignment getFuncAssignment_1() { return cFuncAssignment_1; }

		//[AbstractFunction]
		public CrossReference getFuncAbstractFunctionCrossReference_1_0() { return cFuncAbstractFunctionCrossReference_1_0; }

		//ID
		public RuleCall getFuncAbstractFunctionIDTerminalRuleCall_1_0_1() { return cFuncAbstractFunctionIDTerminalRuleCall_1_0_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//(args+=Expression ("," args+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }

		//args+=Expression
		public Assignment getArgsAssignment_3_0() { return cArgsAssignment_3_0; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_0_0() { return cArgsExpressionParserRuleCall_3_0_0; }

		//("," args+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }

		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }

		//args+=Expression
		public Assignment getArgsAssignment_3_1_1() { return cArgsAssignment_3_1_1; }

		//Expression
		public RuleCall getArgsExpressionParserRuleCall_3_1_1_0() { return cArgsExpressionParserRuleCall_3_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class VarOrArgumentCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "VarOrArgumentCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cVarOrArgumentCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cCallAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cCallAbstractVarOrArgumentCrossReference_1_0 = (CrossReference)cCallAssignment_1.eContents().get(0);
		private final RuleCall cCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1 = (RuleCall)cCallAbstractVarOrArgumentCrossReference_1_0.eContents().get(1);
		
		//VarOrArgumentCall returns Expression:
		//	{VarOrArgumentCall} call=[AbstractVarOrArgument];
		public ParserRule getRule() { return rule; }

		//{VarOrArgumentCall} call=[AbstractVarOrArgument]
		public Group getGroup() { return cGroup; }

		//{VarOrArgumentCall}
		public Action getVarOrArgumentCallAction_0() { return cVarOrArgumentCallAction_0; }

		//call=[AbstractVarOrArgument]
		public Assignment getCallAssignment_1() { return cCallAssignment_1; }

		//[AbstractVarOrArgument]
		public CrossReference getCallAbstractVarOrArgumentCrossReference_1_0() { return cCallAbstractVarOrArgumentCrossReference_1_0; }

		//ID
		public RuleCall getCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1() { return cCallAbstractVarOrArgumentIDTerminalRuleCall_1_0_1; }
	}

	public class NodeDepthElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NodeDepth");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNODEKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cPrimaryNodeRefParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cDepthAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cDepthPrimaryNodeRefParserRuleCall_2_1_0 = (RuleCall)cDepthAssignment_2_1.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cResRefAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cResRefResourceCrossReference_4_0 = (CrossReference)cResRefAssignment_4.eContents().get(0);
		private final RuleCall cResRefResourceIDTerminalRuleCall_4_0_1 = (RuleCall)cResRefResourceCrossReference_4_0.eContents().get(1);
		
		//NodeDepth:
		//	"NODE." PrimaryNodeRef ("." depth+=PrimaryNodeRef)* "." resRef=[library::Resource];
		public ParserRule getRule() { return rule; }

		//"NODE." PrimaryNodeRef ("." depth+=PrimaryNodeRef)* "." resRef=[library::Resource]
		public Group getGroup() { return cGroup; }

		//"NODE."
		public Keyword getNODEKeyword_0() { return cNODEKeyword_0; }

		//PrimaryNodeRef
		public RuleCall getPrimaryNodeRefParserRuleCall_1() { return cPrimaryNodeRefParserRuleCall_1; }

		//("." depth+=PrimaryNodeRef)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//depth+=PrimaryNodeRef
		public Assignment getDepthAssignment_2_1() { return cDepthAssignment_2_1; }

		//PrimaryNodeRef
		public RuleCall getDepthPrimaryNodeRefParserRuleCall_2_1_0() { return cDepthPrimaryNodeRefParserRuleCall_2_1_0; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }

		//resRef=[library::Resource]
		public Assignment getResRefAssignment_4() { return cResRefAssignment_4; }

		//[library::Resource]
		public CrossReference getResRefResourceCrossReference_4_0() { return cResRefResourceCrossReference_4_0; }

		//ID
		public RuleCall getResRefResourceIDTerminalRuleCall_4_0_1() { return cResRefResourceIDTerminalRuleCall_4_0_1; }
	}

	public class PrimaryNodeRefElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimaryNodeRef");
		private final Assignment cNodeRefAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cNodeRefNodeCrossReference_0 = (CrossReference)cNodeRefAssignment.eContents().get(0);
		private final RuleCall cNodeRefNodeIDTerminalRuleCall_0_1 = (RuleCall)cNodeRefNodeCrossReference_0.eContents().get(1);
		
		//PrimaryNodeRef:
		//	nodeRef=[library::Node];
		public ParserRule getRule() { return rule; }

		//nodeRef=[library::Node]
		public Assignment getNodeRefAssignment() { return cNodeRefAssignment; }

		//[library::Node]
		public CrossReference getNodeRefNodeCrossReference_0() { return cNodeRefNodeCrossReference_0; }

		//ID
		public RuleCall getNodeRefNodeIDTerminalRuleCall_0_1() { return cNodeRefNodeIDTerminalRuleCall_0_1; }
	}
	
	
	private ModElements pMod;
	private ImportElements pImport;
	private FunctionElements pFunction;
	private ArgumentElements pArgument;
	private AbstractVarOrArgumentElements pAbstractVarOrArgument;
	private AbstractFunctionElements pAbstractFunction;
	private BlockElements pBlock;
	private StatementElements pStatement;
	private VariableStatementElements pVariableStatement;
	private ExpressionElements pExpression;
	private LogicalElements pLogical;
	private EqualityElements pEquality;
	private ComparisonElements pComparison;
	private AdditionElements pAddition;
	private MultiplicationElements pMultiplication;
	private UnaryElements pUnary;
	private UnaryOperatorElements pUnaryOperator;
	private PrimaryExpressionElements pPrimaryExpression;
	private FunctionCallElements pFunctionCall;
	private VarOrArgumentCallElements pVarOrArgumentCall;
	private NodeDepthElements pNodeDepth;
	private PrimaryNodeRefElements pPrimaryNodeRef;
	private TerminalRule tNUMBER;
	private TerminalRule tBOOLEAN;
	private TerminalRule tINT;
	
	private final GrammarProvider grammarProvider;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public NetxscriptGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammarProvider = grammarProvider;
		this.gaTerminals = gaTerminals;
	}
	
	public Grammar getGrammar() {	
		return grammarProvider.getGrammar(this);
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Mod:
	//	"mod" name=ID imports+=Import* functions+=Function+;
	public ModElements getModAccess() {
		return (pMod != null) ? pMod : (pMod = new ModElements());
	}
	
	public ParserRule getModRule() {
		return getModAccess().getRule();
	}

	//Import:
	//	"import" importURI=STRING;
	public ImportElements getImportAccess() {
		return (pImport != null) ? pImport : (pImport = new ImportElements());
	}
	
	public ParserRule getImportRule() {
		return getImportAccess().getRule();
	}

	////ImportName:
	////	ID ('.' '*')?;
	//// TODO, we can't have mandatory brackets, as this would conflict with our PrimaryExpression. 
	//Function:
	//	"def" name=ID "(" (args+=Argument ("," args+=Argument)*)? ")" block=Block;
	public FunctionElements getFunctionAccess() {
		return (pFunction != null) ? pFunction : (pFunction = new FunctionElements());
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//Argument:
	//	name=ID;
	public ArgumentElements getArgumentAccess() {
		return (pArgument != null) ? pArgument : (pArgument = new ArgumentElements());
	}
	
	public ParserRule getArgumentRule() {
		return getArgumentAccess().getRule();
	}

	//AbstractVarOrArgument:
	//	VariableStatement | Argument;
	public AbstractVarOrArgumentElements getAbstractVarOrArgumentAccess() {
		return (pAbstractVarOrArgument != null) ? pAbstractVarOrArgument : (pAbstractVarOrArgument = new AbstractVarOrArgumentElements());
	}
	
	public ParserRule getAbstractVarOrArgumentRule() {
		return getAbstractVarOrArgumentAccess().getRule();
	}

	//AbstractFunction:
	//	Function;
	public AbstractFunctionElements getAbstractFunctionAccess() {
		return (pAbstractFunction != null) ? pAbstractFunction : (pAbstractFunction = new AbstractFunctionElements());
	}
	
	public ParserRule getAbstractFunctionRule() {
		return getAbstractFunctionAccess().getRule();
	}

	//Block:
	//	"{" {Block} statements+=Statement* "}";
	public BlockElements getBlockAccess() {
		return (pBlock != null) ? pBlock : (pBlock = new BlockElements());
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//Statement:
	//	{BlankStatement} ";" | VariableStatement ";" | Block;
	public StatementElements getStatementAccess() {
		return (pStatement != null) ? pStatement : (pStatement = new StatementElements());
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//VariableStatement returns Statement:
	//	expression=Expression | {Variable} name=ID "=" expression=Expression;
	public VariableStatementElements getVariableStatementAccess() {
		return (pVariableStatement != null) ? pVariableStatement : (pVariableStatement = new VariableStatementElements());
	}
	
	public ParserRule getVariableStatementRule() {
		return getVariableStatementAccess().getRule();
	}

	//// Expression, all operators extend this class. 
	//Expression:
	//	Logical;
	public ExpressionElements getExpressionAccess() {
		return (pExpression != null) ? pExpression : (pExpression = new ExpressionElements());
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// Logical	
	//Logical returns Expression:
	//	Equality (({And.left=current} "&&" | {Or.left=current} "||") right=Equality)*;
	public LogicalElements getLogicalAccess() {
		return (pLogical != null) ? pLogical : (pLogical = new LogicalElements());
	}
	
	public ParserRule getLogicalRule() {
		return getLogicalAccess().getRule();
	}

	//// Equal, Non-Equal 
	//Equality returns Expression:
	//	Comparison (({Equal.left=current} "==" | {Unequal.left=current} "!=") right=Comparison)*;
	public EqualityElements getEqualityAccess() {
		return (pEquality != null) ? pEquality : (pEquality = new EqualityElements());
	}
	
	public ParserRule getEqualityRule() {
		return getEqualityAccess().getRule();
	}

	//// Lesser, Greater. 
	//Comparison returns Expression:
	//	Addition (({Lesser.left=current} "<" | {LesserEqual.left=current} "<=" | {Greater.left=current} ">" |
	//	{GreaterEqual.left=current} ">=") right=Addition)*;
	public ComparisonElements getComparisonAccess() {
		return (pComparison != null) ? pComparison : (pComparison = new ComparisonElements());
	}
	
	public ParserRule getComparisonRule() {
		return getComparisonAccess().getRule();
	}

	//Addition returns Expression:
	//	Multiplication (({Plus.left=current} "+" | {Minus.left=current} "-") right=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return (pAddition != null) ? pAddition : (pAddition = new AdditionElements());
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns Expression:
	//	Unary (({Multi.left=current} "*" | {Div.left=current} "/" | {Modulo.left=current} "%") right=Unary)*;
	public MultiplicationElements getMultiplicationAccess() {
		return (pMultiplication != null) ? pMultiplication : (pMultiplication = new MultiplicationElements());
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//// Unaries are return type specific. The type on the right should be checked.  
	//Unary returns Expression:
	//	PrimaryExpression | ({Negation} op="!" | {UnaryPlusMinus} op=UnaryOperator) right=Unary;
	public UnaryElements getUnaryAccess() {
		return (pUnary != null) ? pUnary : (pUnary = new UnaryElements());
	}
	
	public ParserRule getUnaryRule() {
		return getUnaryAccess().getRule();
	}

	//UnaryOperator:
	//	"-" | "+";
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return (pUnaryOperator != null) ? pUnaryOperator : (pUnaryOperator = new UnaryOperatorElements());
	}
	
	public ParserRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}

	//// TODO, a functionCall is not necessarly an abstract definition in this grammar, but could 
	//// be an internal function call. For this we could mixin, a grammar which contains
	//// all internal calls.
	//// The FunctionCall and potential parameters, shoul be checked as reference priot to a regular Assignment call. 
	//PrimaryExpression returns Expression:
	//	"(" Expression ")" | {NumberLiteral} value=NUMBER | {BooleanLiteral} condition?=BOOLEAN | {ModelReference}
	//	node=NodeDepth | FunctionCall | VarOrArgumentCall;
	public PrimaryExpressionElements getPrimaryExpressionAccess() {
		return (pPrimaryExpression != null) ? pPrimaryExpression : (pPrimaryExpression = new PrimaryExpressionElements());
	}
	
	public ParserRule getPrimaryExpressionRule() {
		return getPrimaryExpressionAccess().getRule();
	}

	//FunctionCall returns Expression:
	//	{FunctionCall} func=[AbstractFunction] "(" (args+=Expression ("," args+=Expression)*)? ")";
	public FunctionCallElements getFunctionCallAccess() {
		return (pFunctionCall != null) ? pFunctionCall : (pFunctionCall = new FunctionCallElements());
	}
	
	public ParserRule getFunctionCallRule() {
		return getFunctionCallAccess().getRule();
	}

	//VarOrArgumentCall returns Expression:
	//	{VarOrArgumentCall} call=[AbstractVarOrArgument];
	public VarOrArgumentCallElements getVarOrArgumentCallAccess() {
		return (pVarOrArgumentCall != null) ? pVarOrArgumentCall : (pVarOrArgumentCall = new VarOrArgumentCallElements());
	}
	
	public ParserRule getVarOrArgumentCallRule() {
		return getVarOrArgumentCallAccess().getRule();
	}

	//NodeDepth:
	//	"NODE." PrimaryNodeRef ("." depth+=PrimaryNodeRef)* "." resRef=[library::Resource];
	public NodeDepthElements getNodeDepthAccess() {
		return (pNodeDepth != null) ? pNodeDepth : (pNodeDepth = new NodeDepthElements());
	}
	
	public ParserRule getNodeDepthRule() {
		return getNodeDepthAccess().getRule();
	}

	//PrimaryNodeRef:
	//	nodeRef=[library::Node];
	public PrimaryNodeRefElements getPrimaryNodeRefAccess() {
		return (pPrimaryNodeRef != null) ? pPrimaryNodeRef : (pPrimaryNodeRef = new PrimaryNodeRefElements());
	}
	
	public ParserRule getPrimaryNodeRefRule() {
		return getPrimaryNodeRefAccess().getRule();
	}

	//terminal NUMBER returns ecore::EBigDecimal:
	//	"0".."9"* ("." "0".."9"+)?;
	public TerminalRule getNUMBERRule() {
		return (tNUMBER != null) ? tNUMBER : (tNUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "NUMBER"));
	} 

	//terminal BOOLEAN returns ecore::EBoolean:
	//	"true" | "false";
	public TerminalRule getBOOLEANRule() {
		return (tBOOLEAN != null) ? tBOOLEAN : (tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "BOOLEAN"));
	} 

	////How to deal with FQN??
	////terminal KEYWORD returns ecore::EString:
	////	'this' | 'period' | 'NODE' | 'SERVICE' | 'SERVICEPROFILE' | 'SERVICEPROFILE'
	////	'SERVICEDISTRIBUTION' | 'RFSSERVICE' | 'METRIC' | 'LINK' | 'RESOURCE'| 'EQUIPMENT' | 'FUNCTION';
	//terminal INT returns ecore::EInt:
	//	"this one has been deactivated";
	public TerminalRule getINTRule() {
		return (tINT != null) ? tINT : (tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "INT"));
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
