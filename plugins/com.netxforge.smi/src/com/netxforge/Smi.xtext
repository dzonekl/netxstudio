/**
 * 
 * Xtext grammar for:  
 *
 * Structure of Management Information Version 2 (SMIv2)
 * http://tools.ietf.org/html/rfc2578
 * 
 * ASN.1 Notation from: 
 * 
 * Author: Christophe Bouhier
 * 2013
 * 
 * This grammar defines SMIv2 but is also capable to process SMIv2 Information Modules.
 *  
 * 
 * Disclaimer
 * 
 * Design
 * ------
 * ASN1 has grammar constraints for where type, value assignments, Macro's etc... should start (On a new line) 
 * There for we do not hide the CR/LF tokens when lexing. As new line occurences elsewhere in the grammar are
 * included in various rules. lile befor a 'BEGIN' keyword. Although this doesn't improve the readability it allows 
 * very detailed control on each rule. 
 * 
 * Version History
 * ---------------
 * 1.0 Initial version 
 * - Support for Macro's 
 * - Support for Object Identifiers
 * 
 * 
 */
grammar com.netxforge.Smi hidden(WS, SL_ASN1_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate smi "http://www.netxforge.com/Smi"

Module:
	name=MODULE_ID 'DEFINITIONS' '::=' 'BEGIN' NEWLINE
	(identifiers+=ObjectIdentifier |
	types+=TypeDefinition |
	macros+=Macro)+
	NEWLINE 'END' NEWLINE*;

	// An ASN.1 Object Identifier
ObjectIdentifier hidden(WS, SL_ASN1_COMMENT):
	NEWLINE+ name=ASN1_ID 'OBJECT IDENTIFIER' '::=' '{' oidValue=ObjectIdentifierValue '}';

	// The value of the Object identifier	
ObjectIdentifierValue:
	(root=ASN1_ID
	| => descriptorReference=[ObjectIdentifier|ASN1_ID])? subIds+=INT (subIds+=INT)*;

	// An ASN.1 Value assignment. 
TypeDefinition:
	NEWLINE+ name=(MODULE_ID) '::=' values+=Value+;

//Scope:
//	name='::=' values+=Value+;

	// An ASN.1 Macro structure
Macro:
	NEWLINE+ name=MODULE_ID 'MACRO' '::='
	NEWLINE 'BEGIN'
	NEWLINE+ 'TYPE NOTATION' '::=' typeNotations+=TypeAssignment+ // Reference one or more type assignment. 
	NEWLINE+ 'VALUE NOTATION' '::=' NEWLINE? valueNotation=MacroValue // Define one Macro value. 
	innerTypes+=TypeDefinition+ // Define 1 or more type definitions
	NEWLINE+ 'END';

	// An ASN.1 Macro Type Notation, it's slightly different then  a type definition. 
TypeAssignment:
	NEWLINE+ (ParamAssignment | TypeReference | MacroValue);

	// An ASN.1 Parameter assignment
ParamAssignment:
	param=PARAMETER right=TypeNotation;

TypeNotation:
	TypeReference | value=MacroValue;

	// Types can be referred once or twice. The right side is named a child reference. 
TypeReferenceExt returns TypeAssignment:
	parentRef=TypeReference (=> childRef=TypeReference)?;

TypeReference returns TypeAssignment:
	type=[TypeDefinition|MODULE_ID];

Value:
	NEWLINE? valueTypes+=ValueType (NEWLINE? '|' valueTypes+=ValueType)*;

ValueType:
	(param=ParamAssignment | types=TypeReferenceExt | simpleType=ASN1_TYPE | macroValue=MacroValue |
	oi='OBJECT IDENTIFIER');

MacroValue returns Value:
	{MacroValue} 'value' '(' valueType=MACRO_VALUE_TYPE ')';

MACRO_VALUE_TYPE:
	update=UpdateType | literal=MACRO_VALUE_CAP;

UpdateType:
	'Update' type=[TypeDefinition|MODULE_ID];

	// Add other options.
MACRO_VALUE_CAP:
	'VALUE OBJECT IDENTIFIER' | 'IA5String';

	//enum VALUE_CAP_LITERALS:
//	oiLiteral='OBJECT IDENTIFIER' | ia5StringLiteral='IA5String';

// Simple and structured types. 
ASN1_TYPE:
	ASN1_SIMPLE | ASN1_CHOICE;

	// -- the "base types" defined here are:
// --   3 built-in ASN.1 types: INTEGER, OCTET STRING, OBJECT IDENTIFIER
ASN1_SIMPLE returns ASN1_TYPE:
	{ASN1_SIMPLE} 'empty' | {ASN1_SIMPLE} IA5STRING | ASN1_OCTET_STRING constraint=ASN1_SUBTYPE? | ASN1_INTEGER
	constraint=ASN1_RANGE?;

ASN1_OCTET_STRING returns ASN1_SIMPLE:
	{ASN1_OCTET_STRING} name='OCTET STRING';

ASN1_INTEGER returns ASN1_SIMPLE:
	name='INTEGER' '{' (valuePairs+=ASN1_VALUEPAIR)+ '}';

ASN1_SUBTYPE returns ASN1_SIMPLE:
	'(' 'SIZE' '(' ranges+=ASN1_RANGE
	('|' ranges+=ASN1_RANGE)* ')' ')';

ASN1_RANGE:
	{ASN1_RANGE} value=INT | (start=INT '..' end=INT);

	// TODO1 Requries further definition. 	

// TODO1 further specify id, as enum entry in the vp
ASN1_VALUEPAIR:
	(ASN1_ID)? '(' INT ')';

	//Choice:
// http://www.obj-sys.com/asn1tutorial/node11.html
ASN1_CHOICE:
	 'CHOICE' '{' choices+=ASN1_CHOICE_ENTRY (',' choices+=ASN1_CHOICE_ENTRY)* '}';

	// TODO1 The reference to a ValueType is indented by 4 WS on the next line. 
//  
ASN1_CHOICE_ENTRY:
	id=ASN1_ID valueType=[Value|ASN1_ID];

terminal MODULE_ID:
	(ALPHA_CAP) (ALPHA | ALPHA_CAP | '-' | NUMERIC)* (ALPHA_CAP | ALPHA | NUMERIC);

terminal ASN1_ID:
	(ALPHA) (ALPHA | ALPHA_CAP | '-' | NUMERIC)*;

terminal PARAMETER:
	'"' MODULE_ID '"';

terminal IA5STRING:
	'"' ('\\' ('b'
	| 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '"';

	// Fragments.
terminal fragment NUMERIC:
	'0'..'9';

terminal fragment ALPHA:
	'a'..'z';

terminal fragment ALPHA_CAP:
	'A'..'Z';

terminal INT returns ecore::EInt:
	('0'..'9')+;

	// Section 3.4 
// ... ASN.1 comments commence with a pair of adjacent hyphens and end with
// the next pair of adjacent hyphens or at the end of the line,
// whichever occurs first.  Comments ended by a pair of hyphens have the
// effect of a single space character.

// TODO1 Comments ended by a pair of hyphens have the effect of a single space character.
terminal SL_ASN1_COMMENT:
	'--' !('\n' | '\r')*;

terminal WS:
	(' ' | '\t')+;

terminal NEWLINE:
	'\r'? | '\n';

terminal ANY_OTHER:
	.;